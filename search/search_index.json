{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#archetype-ecs-lib","title":"Archetype ECS Lib","text":"<p>A tiny archetype-based ECS (Entity Component System) for TypeScript.</p> <p>This documentation is split into 4 parts :</p> <ul> <li>Explanation the general operation of the library</li> <li>Find information in the Reference</li> <li>Target a specific goal using the How-To Guides</li> <li>Learn through the Tutorials: step-by-step guidance</li> </ul>"},{"location":"#install","title":"Install","text":"<p>NPM package available here</p> <pre><code>npm i archetype-ecs-lib\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>import { World, Schedule } from \"archetype-ecs-lib\";\n\nclass Position { constructor(public x = 0, public y = 0) {} }\nclass Velocity { constructor(public x = 0, public y = 0) {} }\n\nconst world = new World();\n\n// Spawn immediately\nconst e = world.spawn();\nworld.add(e, Position, new Position(0, 0));\nworld.add(e, Velocity, new Velocity(1, 0));\n\n// A simple system\nworld.addSystem((w) =&gt; {\n  for (const { e, c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x * dt;\n    pos.y += vel.y * dt;\n\n    // Defer structural changes safely\n    if (pos.x &gt; 10) w.cmd().despawn(e);\n  }\n});\n\nworld.update(1 / 60);\n</code></pre> <p>Note: <code>SystemFn</code> is typed as <code>(world: WorldApi, dt) =&gt; void</code>. Checkout the tutorials for more!  </p>"},{"location":"#notes-limitations","title":"Notes &amp; limitations","text":"<ul> <li>This is intentionally minimal: no parallelism, no borrow-checking, no automatic conflict detection.</li> <li>Query results use <code>c1/c2/...</code> fields for stability and speed; you can wrap this in helpers if you prefer tuple returns.</li> <li><code>TypeId</code> assignment is process-local and based on constructor identity (<code>WeakMap</code>).</li> </ul>"},{"location":"#license","title":"License","text":"<p>This code is distributed under the terms and conditions of the MIT license.</p>"},{"location":"Demo/","title":"Demo","text":"<p>Here is a small representation example using the library. The frontend was built with Vite</p> <p>Open demo in a new tab</p>"},{"location":"Explanation/Understanding-ECS-Debugging-%26-Profiling/","title":"Understanding ECS Debugging &amp; Profiling","text":""},{"location":"Explanation/Understanding-ECS-Debugging-%26-Profiling/#why-debugging-ecs-is-different","title":"Why Debugging ECS is Different","text":"<p>Entity Component System architectures present unique debugging challenges compared to traditional object-oriented code. Instead of inspecting individual objects with encapsulated state, you're dealing with:</p> <ul> <li>Entities: Just numeric IDs with no inherent meaning</li> <li>Components: Data scattered across archetype tables</li> <li>Systems: Functions that operate on query results, not objects</li> <li>Deferred operations: Commands that execute later, not when called</li> </ul> <p>This separation of data and logic makes traditional breakpoint debugging less intuitive. You can't simply \"step into\" an entity to see what it's doing.</p>"},{"location":"Explanation/Understanding-ECS-Debugging-%26-Profiling/#the-stats-overlay-philosophy","title":"The Stats Overlay Philosophy","text":"<p>The built-in stats overlay provides runtime observability rather than step-through debugging. It answers questions like:</p> <ul> <li>\"How many entities exist right now?\"</li> <li>\"Which systems are slow?\"</li> <li>\"Are my archetypes fragmenting?\"</li> <li>\"Is my frame budget being exceeded?\"</li> </ul> <p>This approach aligns with how games and simulations are typically debugged\u2014by observing the running system rather than pausing it.</p>"},{"location":"Explanation/Understanding-ECS-Debugging-%26-Profiling/#what-the-metrics-mean","title":"What the Metrics Mean","text":""},{"location":"Explanation/Understanding-ECS-Debugging-%26-Profiling/#entity-archetype-counts","title":"Entity &amp; Archetype Counts","text":"<p>The relationship between alive entities, archetypes, and rows tells you about your data layout:</p> Metric Healthy Sign Warning Sign Archetypes Stable, low count Growing unboundedly Rows \u2248 Entities Close match Large gap indicates fragmentation Entities Predictable growth Unexpected spikes <p>Archetype explosion occurs when entities frequently add/remove components, creating many unique component combinations. Each unique combination requires its own archetype table.</p>"},{"location":"Explanation/Understanding-ECS-Debugging-%26-Profiling/#frame-timing","title":"Frame Timing","text":"<p>The overlay tracks two time measurements:</p> <ul> <li>dt: Delta time passed to <code>update()</code> (what your game logic sees)</li> <li>frame: Actual wall-clock time spent in the update (what the CPU experiences)</li> </ul> <p>When <code>frame</code> consistently exceeds <code>dt</code>, you're falling behind real-time.</p>"},{"location":"Explanation/Understanding-ECS-Debugging-%26-Profiling/#phase-system-timing","title":"Phase &amp; System Timing","text":"<p>With the <code>Schedule</code> API, systems are grouped into phases. The overlay shows:</p> <ul> <li>Per-phase total time</li> <li>Per-system time (when profiling is enabled)</li> </ul> <p>This helps identify which phase or system is the bottleneck.</p>"},{"location":"Explanation/Understanding-ECS-Debugging-%26-Profiling/#profiling-history","title":"Profiling History","text":"<p>The overlay maintains a rolling history (default: 120 frames) displayed as a bar graph:</p> <ul> <li>Blue bars: Frames within budget (\u2264 slow threshold)</li> <li>Red bars: Slow frames (&gt; slow threshold)</li> <li>White line: Target frame time</li> </ul> <p>Patterns in this graph reveal:</p> <ul> <li>Periodic spikes: Often garbage collection or physics sync</li> <li>Gradual increase: Memory leak or unbounded growth</li> <li>Consistent red: Fundamental performance problem</li> </ul>"},{"location":"Explanation/Understanding-ECS-Debugging-%26-Profiling/#debug-logging","title":"Debug Logging","text":"<p>The / toggle enables console output of phase timings each frame. This is useful for:</p> <ul> <li>Capturing timing data for analysis</li> <li>Correlating visual stutters with logged spikes</li> <li>Automated performance regression testing</li> </ul>"},{"location":"Explanation/ecs-and-the-game-loop/","title":"ECS and the game loop","text":"<p>ECS is best understood as the way you organize game state and game logic, not as the thing that does everything. In a typical game, the loop still has input, rendering, audio, physics, networking, etc. ECS provides a consistent place for runtime data (components) and behavior (systems), plus a schedule that defines when that behavior runs. This library already models this explicitly with <code>World.update(dt)</code> and with a phase-based <code>Schedule</code> that flushes between phases. </p>"},{"location":"Explanation/ecs-and-the-game-loop/#frame-phases","title":"Frame phases","text":"<p>A \u201cframe\u201d is rarely just \u201cupdate then draw\u201d. Most games are structured in phases, even if informally. A common conceptual breakdown:</p> <ol> <li>Input: read devices/events, translate into game intent</li> <li>Simulation: movement, AI, gameplay rules, timers</li> <li>Physics (optional separate step): integrate, solve collisions, constraints</li> <li>Post-sim: resolve gameplay outcomes, spawn/despawn, apply state transitions</li> <li>Render prep: build renderable data, sort, cull</li> <li>Render: submit to GPU / engine renderer</li> <li>End-of-frame: cleanup, present frame, etc.</li> </ol> <p>The <code>Schedule</code> is designed exactly for this idea: you define phases (strings) and run them in order, with <code>flush()</code> after each phase. </p>"},{"location":"Explanation/ecs-and-the-game-loop/#where-ecs-fits","title":"Where ECS fits","text":"<p>ECS typically fits in the simulation and render-prep parts of the loop:</p> <ul> <li>World holds the mutable runtime state (entities + components) </li> <li>Systems implement the game logic by querying components and mutating them</li> <li>Commands allow safe structural changes during those systems (<code>cmd()</code> \u2192 <code>flush()</code>) </li> <li>Schedule provides deterministic ordering and safe mutation boundaries between phases </li> </ul> <p>A useful mental model:</p> <ul> <li>Rendering engines want a renderable snapshot (meshes, transforms, materials, draw lists).</li> <li>Input systems produce intent/state (move left, fire, target position).</li> <li>Physics engines operate on physical representations (bodies, colliders).</li> </ul> <p>ECS sits in the middle coordinating these, not replacing them.</p>"},{"location":"Explanation/ecs-and-the-game-loop/#a-concrete-mapping-using-this-primitives","title":"A concrete mapping using this primitives","text":"<ul> <li>Input phase: read input \u2192 write <code>InputState</code> component / resource \u2192 enqueue spawns/despawns if needed</li> <li><code>flush()</code></li> <li>Sim phase: run movement/AI/gameplay using queries \u2192 update <code>Position</code>, <code>Velocity</code>, etc.</li> <li><code>flush()</code></li> <li>Render phase: build lightweight render data (<code>RenderTransform</code>, <code>Visible</code>, etc.) \u2192 hand off to renderer</li> </ul> <p>This is why \u201cflush points\u201d exist in an ECS schedule: they define when the world structure is allowed to change and when the next phase sees those changes. </p>"},{"location":"Explanation/ecs-and-the-game-loop/#why-ecs-does-not-replace-rendering-input-or-physics-engines","title":"Why ECS does not replace rendering, input, or physics engines","text":""},{"location":"Explanation/ecs-and-the-game-loop/#rendering","title":"Rendering","text":"<p>A renderer is a specialized pipeline:</p> <ul> <li>GPU resources, shaders, batching, sorting, culling</li> <li>frame graph / render passes</li> <li>platform-specific backends</li> </ul> <p>ECS is not a GPU pipeline. What ECS does well is:</p> <ul> <li>storing render-related data as components (<code>Transform</code>, <code>Renderable</code>, <code>MaterialRef</code>, etc.)</li> <li>running systems that prepare and synchronize data for the renderer</li> </ul> <p>So ECS often produces a render list or updates engine scene objects, but the renderer still does the rendering.</p>"},{"location":"Explanation/ecs-and-the-game-loop/#input","title":"Input","text":"<p>Input is inherently eventful and platform-driven:</p> <ul> <li>OS/window events</li> <li>device state polling</li> <li>mapping raw events to game actions</li> </ul> <p>ECS can store input state (<code>InputAxis</code>, <code>ActionPressed</code>, etc.) and process it in systems, but it doesn\u2019t replace the platform input layer. In practice:</p> <ul> <li>platform collects input</li> <li>ECS system transforms it into gameplay-friendly state</li> </ul>"},{"location":"Explanation/ecs-and-the-game-loop/#physics","title":"Physics","text":"<p>Physics engines are optimized solvers:</p> <ul> <li>broadphase / narrowphase collision detection</li> <li>integrators and constraint solvers</li> <li>continuous collision, joints, sleeping, etc.</li> </ul> <p>ECS can represent physics data (mass, collider type, desired forces) and drive the physics engine, but the solver itself is a dedicated subsystem.</p> <p>A common integration pattern:</p> <ul> <li>ECS \u2192 write forces/desired velocity into physics engine</li> <li>Physics step happens</li> <li>Physics results \u2192 write back transforms/velocities into ECS</li> </ul>"},{"location":"Explanation/ecs-and-the-game-loop/#the-key-idea-ecs-is-the-coordination-model","title":"The key idea: ECS is the coordination model","text":"<p>ECS shines when you treat it as:</p> <ul> <li>a data model for game state (components)</li> <li>a behavior model for game logic (systems)</li> <li>an execution model for ordering (schedule + phases + flush points) </li> </ul> <p>But rendering/input/physics are specialized domains with their own constraints and pipelines. ECS coordinates them by being the \u201ctruth\u201d for game state and by running the logic that translates between subsystems.</p>"},{"location":"Explanation/integrating-an-ecs-with-three.js/","title":"Integrating an ECS with Three.js","text":"<p>Three.js is a rendering engine (scene graph + GPU submission). This ECS is a simulation architecture (data in components, behavior in systems, ordered by a schedule, with safe structural changes via deferred commands + flush points). Integrating them well means letting each do what it\u2019s good at, and defining clean \u201chand-off\u201d boundaries.</p>"},{"location":"Explanation/integrating-an-ecs-with-three.js/#the-mental-model-ecs-drives-state-threejs-draws-it","title":"The mental model: ECS drives state, Three.js draws it","text":"<p>A practical split that scales:</p> <ul> <li>ECS World = authoritative game/sim state (position, velocity, health, selection, etc.) </li> <li>Three.js Scene = visual representation (Object3D transforms, meshes, materials, lights)</li> </ul> <p>So the goal is not \u201cput Three.js inside ECS\u201d, but:</p> <p>Systems write simulation state \u2192 a render-sync step pushes that state into Three.js objects.</p>"},{"location":"Explanation/integrating-an-ecs-with-three.js/#where-ecs-fits-in-the-threejs-render-loop","title":"Where ECS fits in the Three.js render loop","text":"<p>Three.js typically runs:</p> <ol> <li>update (your code)</li> <li><code>renderer.render(scene, camera)</code></li> </ol> <p>With ECS, your \u201cupdate\u201d becomes scheduled phases, e.g.:</p> <ul> <li><code>input</code> (read DOM/input, write components/resources)</li> <li><code>sim</code> (gameplay, movement, AI)</li> <li><code>render</code> (sync ECS \u2192 Three.js, then render)</li> </ul> <p>The <code>Schedule</code> already supports this exact idea and flushes commands between phases to make entity/component creation/removal deterministic.</p>"},{"location":"Explanation/integrating-an-ecs-with-three.js/#why-flush-points-matter-for-threejs-integration","title":"Why flush points matter for Three.js integration","text":"<p>Spawning/despawning and add/remove are structural changes in this ECS and are expected to be deferred while iterating queries/systems.</p> <p>That maps perfectly to Three.js object lifecycle:</p> <ul> <li>During sim: decide \u201cthis entity should appear/disappear\u201d \u2192 enqueue ECS commands</li> <li>At flush boundary: ECS structure becomes stable</li> <li>Render-sync phase: create/remove corresponding <code>Object3D</code> safely, because you\u2019re no longer mid-iteration on archetype tables</li> </ul> <p>This is the same reason this ECS has <code>cmd()</code> / <code>flush()</code> and why <code>Schedule</code> flushes between phases.</p>"},{"location":"Explanation/integrating-an-ecs-with-three.js/#a-clean-integration-pattern-renderable-bridge-components","title":"A clean integration pattern: \u201cRenderable bridge\u201d components","text":"<p>Common approach:</p> <ul> <li>A <code>Transform</code> component (position/rotation/scale) is owned by ECS.</li> <li>A <code>Renderable</code> component carries a reference/handle to what Three.js should draw (mesh id, model key, material key\u2026).</li> <li>A render-sync system queries <code>(Transform, Renderable)</code> and applies changes to the corresponding <code>Object3D</code>.</li> </ul> <p>Key idea: ECS components store \u201cwhat it is\u201d and \u201cwhere it is\u201d, while the actual <code>Mesh/Object3D</code> lives in Three.js.</p> <p>This keeps:</p> <ul> <li>ECS portable (not tied to Three.js types everywhere)</li> <li>Three.js free to manage GPU resources</li> </ul>"},{"location":"Explanation/integrating-an-ecs-with-three.js/#one-way-vs-two-way-sync-pick-a-source-of-truth","title":"One-way vs two-way sync (pick a source of truth)","text":"<p>Integration gets messy when both ECS and Three.js \u201cown\u201d transforms.</p> <p>A scalable default:</p> <ul> <li>ECS is the source of truth for gameplay transforms.</li> <li>Three.js <code>Object3D</code> is just the projection of that state.</li> </ul> <p>Only do two-way sync when you truly need it (editor gizmos, drag interactions). Even then, treat it as a controlled input step:</p> <ul> <li>read Object3D change in <code>input</code> or <code>tools</code> phase</li> <li>write back to ECS components</li> <li>let sim proceed from ECS again</li> </ul>"},{"location":"Explanation/integrating-an-ecs-with-three.js/#why-ecs-does-not-replace-threejs-and-shouldnt-try","title":"Why ECS does not replace Three.js (and shouldn\u2019t try)","text":"<p>Even with a \u201cfull ECS\u201d architecture, Three.js still owns:</p> <ul> <li>scene graph concerns (parenting, cameras, lights)</li> <li>GPU resource lifetimes (buffers, textures, materials)</li> <li>draw submission, sorting, batching, culling strategies</li> </ul> <p>ECS complements that by making simulation state and logic scalable: archetype tables + queries + systems + scheduling.</p>"},{"location":"Explanation/integrating-an-ecs-with-three.js/#scaling-tips-when-entity-counts-grow","title":"Scaling tips (when entity counts grow)","text":"<p>When you have many similar visuals:</p> <ul> <li>prefer InstancedMesh in Three.js</li> <li>let ECS systems produce instance transforms (dense arrays) from queries</li> <li>upload those transforms once per frame</li> </ul> <p>This aligns with why archetype ECS exists: tight iteration over dense component columns. </p>"},{"location":"Explanation/meaning-of-ecs/","title":"What people mean by a \u201cfull ECS\u201d","text":"<p>\u201cECS\u201d can mean just a storage model (entities + components in some container), or it can mean an entire game/app architecture where most runtime state and behavior flows through an ECS world + schedule + systems.</p> <p>A \u201cfull ECS\u201d is typically an architecture where:</p> <ul> <li>Entities are only IDs/handles (no behavior).</li> <li>Components are only data.</li> <li>Systems are where behavior lives (pure-ish functions operating on data).</li> <li>A World is the single source of truth for runtime state.</li> <li>A Scheduler (or \u201capp loop\u201d) defines when systems run and in what order.</li> <li>Structural changes are controlled (often via a command buffer) so iteration stays safe and fast.</li> </ul> <p>This library already contains several \u201cfull ECS\u201d building blocks: archetype tables (SoA), queries, deferred commands, and a phase-based schedule. </p> <p>What makes it \u201cfull\u201d is less \u201cdo you use archetypes?\u201d and more \u201cdoes the ECS define the whole program\u2019s execution model?\u201d</p>"},{"location":"Explanation/meaning-of-ecs/#ecs-as-architecture-not-just-storage","title":"ECS as architecture, not just storage","text":""},{"location":"Explanation/meaning-of-ecs/#storage-only-ecs-not-full","title":"Storage-only ECS (not \u201cfull\u201d)","text":"<p>This is common in small libs or quick implementations:</p> <ul> <li>Entities: IDs</li> <li>Components: data bags</li> <li>\u201cSystems\u201d: often just loops in user code</li> <li>Little/no scheduling model</li> <li>No consistent lifecycle for input \u2192 simulation \u2192 rendering</li> <li>Structural changes are ad-hoc</li> </ul> <p>You can build a game with this, but the ECS isn\u2019t the organizing principle\u2014it\u2019s a container.</p>"},{"location":"Explanation/meaning-of-ecs/#architecture-ecs-full-ecs","title":"Architecture ECS (\u201cfull ECS\u201d)","text":"<p>Here, ECS is the spine of the app:</p> <ul> <li>There\u2019s a main schedule (often phases like <code>input \u2192 sim \u2192 render</code>).</li> <li>Systems are registered, ordered, and executed consistently each tick.</li> <li>Cross-cutting state is handled intentionally (resources/singletons, events, time, config).</li> <li>Structural changes are made safe/deterministic (command buffers, flush points).</li> <li>You get a uniform pattern for new features: \u201cadd data + add system\u201d.</li> </ul> <p>The <code>Schedule</code> explicitly models phase ordering + flush barriers, which is a key \u201carchitecture ECS\u201d ingredient. </p>"},{"location":"Explanation/meaning-of-ecs/#difference-between-a-library-ecs-and-an-engine-ecs","title":"Difference between a library ECS and an engine ECS","text":""},{"location":"Explanation/meaning-of-ecs/#library-ecs","title":"Library ECS","text":"<p>Goal: provide core ECS mechanics.</p> <p>Typical traits:</p> <ul> <li>Focus on storage + query performance (archetypes/SoA) </li> <li>Minimal assumptions about the rest of the program</li> <li>Simple scheduling (or none), often single-threaded</li> <li>You (the user) integrate input, rendering, physics, assets, scenes, etc.</li> </ul>"},{"location":"Explanation/meaning-of-ecs/#engine-ecs-bevy-unity-dots-etc","title":"Engine ECS (Bevy / Unity DOTS / etc.)","text":"<p>Goal: ECS is the entire runtime framework.</p> <p>Engine ECS usually includes (beyond a library):</p> <ul> <li>A full app lifecycle (startup, update, fixed update, shutdown)</li> <li>Integrated input, rendering, audio, physics, animation, UI</li> <li>Asset pipeline + hot reload + serialization</li> <li>Advanced scheduling: dependency graphs, system sets, run criteria, fixed timesteps</li> <li>Often parallel execution + conflict detection</li> <li>Tooling/editor integration</li> </ul> <p>So: library ECS = the \u201cECS core\u201d. engine ECS = ECS core + everything around it, with ECS as the central organizing model.</p>"},{"location":"Explanation/why-archetype-ecs/","title":"Why archetype ECS?","text":"<p>An archetype ECS organizes entities into tables where every entity in a table shares the same component set, stored in SoA form (one column per component). This library explicitly follows this model: \u201cArchetypes (tables) store entities in a SoA layout\u2026 Queries iterate matching archetypes efficiently\u2026 Commands defer structural changes\u2026\u201d </p> <p>The \u201cwhy\u201d is mostly about making the common case (systems that iterate lots of entities with the same components) extremely fast and predictable.</p>"},{"location":"Explanation/why-archetype-ecs/#cache-locality","title":"Cache locality","text":"<p>Most game/sim systems look like:</p> <ul> <li>\u201cfor all entities with <code>Position</code> and <code>Velocity</code>, update position\u201d</li> <li>\u201cfor all entities with <code>Transform</code> and <code>Renderable</code>, build render data\u201d</li> </ul> <p>With archetypes, those entities live together in a table, and each component is a dense column:</p> <ul> <li><code>Position[]</code> contiguous</li> <li><code>Velocity[]</code> contiguous</li> </ul> <p>So the CPU reads memory sequentially, which is what caches and prefetchers love. That\u2019s the practical meaning of cache locality: fewer cache misses, more work per nanosecond.</p> <p>In the library, this is literally the storage promise: SoA archetype tables + queries over matching archetypes. </p>"},{"location":"Explanation/why-archetype-ecs/#branch-elimination-and-no-join-iteration","title":"Branch elimination (and \u201cno-join\u201d iteration)","text":"<p>In many ECS designs, the core loop must constantly ask:</p> <ul> <li>\u201cdoes this entity have Velocity?\u201d</li> <li>\u201cif yes, fetch it; if not, skip\u201d</li> </ul> <p>That creates branches and scattered memory access.</p> <p>With archetypes, the membership check is moved up:</p> <ol> <li>pick archetypes that already contain all required components</li> <li>iterate their rows</li> </ol> <p>Inside the inner loop, there\u2019s no per-entity \u201chas component?\u201d branching\u2014every row is guaranteed to match. The API reflects that by querying required component types and yielding direct component references (<code>c1</code>, <code>c2</code>, \u2026). </p> <p>This is what people mean by branch elimination in archetype ECS: fewer conditional checks in the hot loop, more straight-line code.</p>"},{"location":"Explanation/why-archetype-ecs/#predictable-iteration","title":"Predictable iteration","text":"<p>Archetype iteration tends to be predictable because:</p> <ul> <li>You iterate dense arrays (rows/columns), not sparse IDs.</li> <li>Results are shaped consistently (<code>e</code>, <code>c1</code>, <code>c2</code>, \u2026 in argument order). </li> <li>Structural changes are controlled: this library emphasizes deferring structural changes via <code>cmd()</code> and applying them at <code>flush()</code> points. </li> <li><code>Schedule</code> adds explicit \u201cphase barriers\u201d by flushing between phases, making the world structure stable during each phase\u2019s iteration. </li> </ul> <p>That predictability is less about \u201cdeterministic order of entities\u201d and more about deterministic rules for when the world can change shape.</p>"},{"location":"Explanation/why-archetype-ecs/#comparison-with-sparse-set-ecs","title":"Comparison with sparse-set ECS","text":"<p>A sparse-set ECS typically stores each component type separately (often as a dense array + sparse index by entity id). It\u2019s excellent for:</p> <ul> <li>fast lookup for a single component type (<code>Position</code> alone)</li> <li>cheap per-component iteration</li> <li>simple storage and often cheaper structural changes for single components</li> </ul> <p>But when a system needs multiple components (<code>Position + Velocity + Mass + Forces</code>), sparse-set often needs some form of join:</p> <ul> <li>iterate one component pool, check membership in the others</li> <li>or intersect sets / hop through indirections</li> </ul> <p>That can introduce:</p> <ul> <li>more branching (<code>if has(...)</code>)</li> <li>more random memory access (chasing indices across pools)</li> </ul> <p>Archetypes flip that trade-off:</p> <ul> <li>multi-component iteration is the \u201chappy path\u201d (no join inside the hot loop)</li> <li>but structural changes can be more expensive because adding/removing a component may move an entity between tables. </li> </ul>"},{"location":"Explanation/why-archetype-ecs/#rule-of-thumb","title":"Rule of thumb","text":"<ul> <li>If your game spends most time in systems that read/write several components per entity, archetypes tend to shine.</li> <li>If your workload is lots of single-component iteration and high churn (constant add/remove), sparse-set can be simpler and sometimes cheaper.</li> </ul>"},{"location":"Explanation/why-archetype-ecs/#the-real-trade-off-why-its-not-always-archetypes","title":"The real trade-off (why it\u2019s not \u201calways archetypes\u201d)","text":"<p>Archetype ECS wins by making the hot loops fast, but it pays for it with:</p> <ul> <li>structural churn cost (moving entities between tables on add/remove)</li> <li>many archetypes if you have lots of component combinations</li> <li>a stronger need for command buffering + flush boundaries to keep iteration safe. </li> </ul> <p>That\u2019s why a \u201cfull ECS\u201d architecture often includes commands + scheduling: it\u2019s the natural partner to archetype storage.</p>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/","title":"Why deferred commands exist in an archetype ECS","text":"<p>In an archetype ECS, deferred commands (a command buffer) are not a \u201cnice-to-have\u201d. They exist because the fastest storage model makes certain mutations unsafe during iteration. The library API expresses this directly with <code>world.cmd()</code>, <code>world.flush()</code>, and <code>Schedule.run(...)/flush barriers</code>. </p>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#archetypes-are-tables-and-queries-walk-those-tables","title":"Archetypes are tables, and queries walk those tables","text":"<p>An archetype ECS stores entities in tables:</p> <ul> <li>one archetype = one component set</li> <li>one row = one entity</li> <li>one column per component type (SoA) </li> </ul> <p>A query like <code>world.query(Position, Velocity)</code> does not \u201cscan entities\u201d. It first selects archetypes that contain the required component columns, then iterates dense rows in those tables. </p> <p>This density is where the performance comes from.</p>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#the-core-problem-structural-changes-move-entities-between-tables","title":"The core problem: structural changes move entities between tables","text":"<p>A structural change is anything that changes the component set of an entity:</p> <ul> <li><code>spawn()</code></li> <li><code>despawn(e)</code></li> <li><code>add(e, Ctor, value)</code></li> <li><code>remove(e, Ctor)</code></li> </ul> <p>In an archetype ECS, <code>add/remove</code> usually means:</p> <ol> <li>remove the entity\u2019s row from its current archetype table</li> <li>insert a row into another archetype table</li> <li>update internal bookkeeping (where the entity lives now)</li> </ol> <p>That is fundamentally different from <code>set(e, Ctor, value)</code>, which just updates a value inside the same row/column.</p> <p>So: structural change = table move.</p>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#why-its-unsafe-to-do-structural-changes-during-a-query","title":"Why it\u2019s unsafe to do structural changes during a query","text":"<p>When you iterate a query, you are conceptually doing:</p> <ul> <li>\u201cfor each matching archetype table\u201d</li> <li>\u201cfor each row index in that table\u201d</li> <li>\u201cread columns at that row\u201d</li> </ul> <p>If you structurally change any entity during this loop, you can break the iteration invariants:</p>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#1-swap-remove-can-invalidate-the-current-row","title":"1) Swap-remove can invalidate the current row","text":"<p>Many archetype implementations remove rows with swap-remove (O(1)): the last row is swapped into the removed row index.</p> <p>If you remove entity A at row <code>i</code>, entity B may be swapped into row <code>i</code>.</p> <ul> <li>If your loop then increments <code>i</code>, entity B might be skipped.</li> <li>Or processed twice depending on iteration strategy.</li> </ul>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#2-moving-entities-changes-which-archetypes-match","title":"2) Moving entities changes which archetypes match","text":"<p>Adding/removing a component can move an entity into or out of the set of archetypes that the query is iterating.</p> <p>If you mutate membership while iterating:</p> <ul> <li>you can end up iterating an archetype that didn\u2019t exist in the matching set at the start</li> <li>or miss entities that moved into a matching archetype</li> </ul>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#3-internal-indices-can-become-stale-mid-loop","title":"3) Internal indices can become stale mid-loop","text":"<p>The library <code>World</code> tracks where an entity lives (which archetype + row). A structural change updates those indices. If you mutate while holding references from the iteration, you can end up with:</p> <ul> <li>stale row pointers</li> <li>stale bookkeeping</li> <li>inconsistent state if multiple mutations occur</li> </ul> <p>Even if you \u201cthink it works\u201d, it\u2019s fragile and will eventually bite.</p>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#deferred-commands-are-the-solution-separate-readiterate-from-mutate-structure","title":"Deferred commands are the solution: separate \u201cread/iterate\u201d from \u201cmutate structure\u201d","text":"<p>A command buffer enforces a clean two-step model:</p> <ol> <li>During iteration: read data, compute decisions, mutate component values (safe)</li> <li>At a safe boundary: apply structural changes in a batch (safe)</li> </ol> <p>That\u2019s exactly what the library documents:</p> <ul> <li><code>world.cmd()</code> enqueues structural operations </li> <li><code>world.flush()</code> applies queued commands </li> <li><code>world.update(dt)</code> runs systems, then flushes at frame end </li> <li><code>Schedule.run(...)</code> flushes between phases, providing deterministic barriers </li> </ul> <p>This is why deferred commands exist: they preserve iteration correctness without giving up table-based performance.</p>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#why-flushing-in-phases-is-architecturally-important","title":"Why flushing in phases is architecturally important","text":"<p>The library <code>Schedule</code> explicitly flushes after each phase. </p> <p>This is not just \u201cnice ordering\u201d. It creates deterministic points where the world\u2019s structure is allowed to change.</p> <p>Example mental model:</p> <ul> <li>Input phase: decide spawns/despawns based on input \u2192 enqueue commands</li> <li>Flush: apply those spawns so they exist for simulation</li> <li>Simulation phase: move things, detect collisions \u2192 enqueue structural changes</li> <li>Flush: apply spawns/despawns/removals before render</li> <li>Render phase: build render data from a stable world snapshot</li> </ul> <p>That separation reduces \u201caction at a distance\u201d bugs and makes debugging easier:</p> <ul> <li>\u201cwhy does entity exist in sim but not render?\u201d \u2192 check which phase flushed it.</li> </ul>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#what-you-gain-by-deferring","title":"What you gain by deferring","text":""},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#correctness","title":"Correctness","text":"<ul> <li>No skipped entities</li> <li>No double-processing due to swap-remove effects</li> <li>Stable iteration semantics</li> </ul>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#determinism","title":"Determinism","text":"<ul> <li>Structural changes occur at explicit boundaries</li> <li>Easier to reason about ordering</li> </ul>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#performance","title":"Performance","text":"<ul> <li>Keeps archetype iteration tight and cache-friendly</li> <li>Batching structural operations reduces churn</li> </ul>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#what-to-do-inside-a-system","title":"What to do inside a system","text":"<p>Inside a system (or a query loop), follow this rule:</p> <ul> <li>\u2705 mutate component values directly (e.g. <code>pos.x += ...</code>)</li> <li>\u2705 enqueue structural changes via <code>cmd()</code></li> <li>\u274c don\u2019t call structural <code>World</code> ops directly mid-iteration</li> </ul>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#summary-the-why-in-one-sentence","title":"Summary: the \u201cwhy\u201d in one sentence","text":"<p>Deferred commands exist because archetype queries iterate dense tables, and structural changes move rows between tables, which can invalidate iteration\u2014so we queue structural changes and apply them at safe flush boundaries (<code>flush()</code> / schedule phases). </p>"},{"location":"Explanation/why-use-Events-in-ECS/","title":"Why use Events in ECS?","text":""},{"location":"Explanation/why-use-Events-in-ECS/#events-solve-a-different-problem-than-components-and-resources","title":"Events solve a different problem than Components and Resources","text":"<p>ECS has three kinds of data:</p> <ul> <li>Components: persistent, per-entity state (Position, Velocity, Health)</li> <li>Resources: persistent, global state (Input, Time, Config, caches)</li> <li>Events: transient messages (Hit happened, Click happened, Play sound)</li> </ul> <p>Trying to represent \u201csomething happened\u201d as a component usually causes awkward designs:</p> <ul> <li>adding/removing \u201cEvent components\u201d becomes structural churn</li> <li>you need cleanup systems to remove them</li> <li>multiple systems race to observe/remove them</li> </ul> <p>Events avoid that by being explicitly transient.</p>"},{"location":"Explanation/why-use-Events-in-ECS/#events-reduce-coupling-between-systems","title":"Events reduce coupling between systems","text":"<p>Without events:</p> <ul> <li><code>combatSystem</code> might call <code>audioSystem</code> directly</li> <li>or it might mutate a shared global array</li> </ul> <p>With events:</p> <ul> <li>producers don\u2019t know consumers exist</li> <li>consumers don\u2019t know who produced the messages</li> </ul> <p>This keeps systems reusable and easy to rearrange in <code>Schedule</code>.</p>"},{"location":"Explanation/why-use-Events-in-ECS/#why-double-buffering","title":"Why double-buffering?","text":"<p>A common bug in event systems is \u201cevents appear while I\u2019m iterating\u201d.</p> <p>Double-buffering prevents that:</p> <ul> <li>consumers read a stable snapshot (<code>read buffer</code>)</li> <li>producers write to a different buffer (<code>write buffer</code>)</li> <li>swap happens at deterministic boundaries</li> </ul> <p>No surprises. No iterator invalidation. No mid-phase visibility.</p>"},{"location":"Explanation/why-use-Events-in-ECS/#why-phase-scoped-delivery","title":"Why phase-scoped delivery?","text":"<p>This ECS already has a concept of phase boundaries:</p> <ul> <li>structural changes are deferred via Commands</li> <li><code>flush()</code> applies them between phases</li> </ul> <p>Events align with the same boundary:</p> <ul> <li><code>swapEvents()</code> delivers events between phases</li> </ul> <p>This makes it easy to design pipelines:</p> <ul> <li><code>input</code> produces actions \u2192 <code>beforeUpdate</code> consumes</li> <li><code>update</code> produces gameplay events \u2192 <code>afterUpdate</code> consumes</li> <li><code>render</code> produces UI/VFX events \u2192 <code>afterRender</code> consumes</li> <li><code>audio</code> consumes sound events</li> </ul>"},{"location":"Explanation/why-use-Events-in-ECS/#trade-offs-and-the-forwarding-pattern","title":"Trade-offs (and the forwarding pattern)","text":"<p>With phase-scoped delivery, an event is visible in the next phase only. To deliver an event across multiple phases (e.g., from <code>update</code> to <code>audio</code>), you forward it by draining and re-emitting.</p> <p>This is deliberate:</p> <ul> <li>it keeps pipelines explicit</li> <li>prevents \u201cstale\u201d events lingering through unrelated phases</li> <li>makes delivery deterministic and easy to debug</li> </ul>"},{"location":"Explanation/world-snapshots-save-load/","title":"World Snapshots (Save and Load)","text":"<p><code>World.snapshot()</code> and <code>World.restore()</code> let you persist ECS data state and rebuild the world later.</p> <p>The key idea is: save only data that belongs to simulation state, and reconstruct runtime behavior from code.</p>"},{"location":"Explanation/world-snapshots-save-load/#what-is-persisted","title":"What is persisted","text":"<p>Snapshot payloads include:</p> <ul> <li>alive entities</li> <li>registered components (serialized through codecs)</li> <li>registered resources (serialized through codecs)</li> <li>allocator state (<code>nextId</code>, free-list, generations) so entity id reuse stays deterministic after load</li> </ul>"},{"location":"Explanation/world-snapshots-save-load/#what-is-not-persisted","title":"What is not persisted","text":"<p>Snapshot payloads intentionally exclude runtime-only behavior:</p> <ul> <li>systems</li> <li>schedules and phase graph</li> <li>pending commands</li> <li>event buffers/channels</li> </ul> <p>After <code>restore(...)</code>, these are clean runtime state and should be set up by normal app boot code.</p>"},{"location":"Explanation/world-snapshots-save-load/#why-codecs-are-explicit-and-opt-in","title":"Why codecs are explicit and opt-in","text":"<p>Snapshot registration is explicit (<code>registerComponentSnapshot</code>, <code>registerResourceSnapshot</code>) for three reasons:</p> <ol> <li>Stable identity    Runtime <code>TypeId</code> values are process-local. Snapshots need stable string keys like <code>\"comp.position\"</code>.</li> <li>Schema control    Not every field should be saved. A codec chooses exactly which data is persisted.</li> <li>Long-term compatibility    Save files can outlive one run. Explicit keys and payload shapes make migration/versioning manageable.</li> </ol>"},{"location":"Explanation/world-snapshots-save-load/#determinism-goals","title":"Determinism goals","text":"<p>Snapshot export is deterministic for the same world state:</p> <ul> <li>entities are emitted in entity-id order</li> <li>component entries are emitted in snapshot-key order</li> <li>resource entries are emitted in snapshot-key order</li> </ul> <p>This makes snapshots useful for debugging, test fixtures, and replay checkpoints.</p>"},{"location":"Explanation/world-snapshots-save-load/#long-term-saves-vs-quick-saves","title":"Long-term saves vs quick saves","text":"<p>The same snapshot format supports both:</p> <ul> <li>quick save/load in memory</li> <li>persisted saves (<code>JSON.stringify(snapshot)</code> to disk/DB/localStorage)</li> </ul> <p>For long-term saves:</p> <ul> <li>keep codec keys stable</li> <li>if schema changes, migrate old payloads before <code>restore()</code></li> </ul>"},{"location":"Explanation/world-snapshots-save-load/#mental-model","title":"Mental model","text":"<p>Think of world snapshots as state serialization, not engine serialization:</p> <ul> <li>engine runtime is rebuilt</li> <li>simulation data is restored</li> </ul> <p>That separation keeps the ECS data-oriented and engine-agnostic.</p>"},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/","title":"How to Debug Your ECS Application","text":""},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#how-to-enable-the-stats-overlay","title":"How to Enable the Stats Overlay","text":"<p>The stats overlay is automatically created when you instantiate a <code>World</code> in a browser environment. However, to enable and show it, use the function <code>setDebugging</code> to true.</p> <pre><code>import { World } from \"archetype-ecs-lib\";\n\nconst world = new World();\nworld.setDebugging(true);\n// Overlay appears automatically in top-left corner\n</code></pre>"},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#customizing-overlay-position-and-appearance","title":"Customizing Overlay Position and Appearance","text":"<pre><code>const world = new World({\n    statsOverlayOptions: {\n        left: 10,           // X position in pixels\n        top: 10,            // Y position in pixels\n        width: 400,         // Canvas width\n        height: 100,        // Canvas height\n        targetFrameMs: 16.67,  // Target frame time (60 FPS)\n        slowFrameMs: 20,       // Threshold for \"slow\" frames\n        maxSamples: 240        // History length in frames\n    }\n});\n</code></pre>"},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#attaching-to-a-custom-container","title":"Attaching to a Custom Container","text":"<pre><code>const debugPanel = document.getElementById(\"debug-panel\");\n\nconst world = new World({\n    statsOverlayOptions: {\n        parent: debugPanel\n    }\n});\n</code></pre>"},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#how-to-identify-slow-systems","title":"How to Identify Slow Systems","text":""},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#step-1-enable-profiling-on-by-default","title":"Step 1: Enable Profiling (On by Default)","text":"<pre><code>world.setProfilingEnabled(true);\n</code></pre>"},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#step-2-check-the-overlay","title":"Step 2: Check the Overlay","text":"<p>Look at the \"Phases\" line in the stats overlay. Systems are shown with their execution time:</p> <pre><code>Phases: update=5.23ms render=2.10ms physics=1.50ms\n</code></pre>"},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#step-3-enable-console-logging-for-details","title":"Step 3: Enable Console Logging for Details","text":"<p>Click the button to toggle console debug logging. Each frame will log phase timings:</p> <pre><code>Phases: update=5.23ms render=2.10ms physics=1.50ms\n</code></pre>"},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#step-4-analyze-the-history-graph","title":"Step 4: Analyze the History Graph","text":"<p>Red bars indicate frames exceeding the slow threshold. Look for patterns:</p> <ul> <li>Isolated spikes \u2192 Likely GC or async operations</li> <li>Periodic spikes \u2192 Check fixed-interval systems</li> <li>Sustained red \u2192 System needs optimization</li> </ul>"},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#how-to-debug-entity-lifecycle-issues","title":"How to Debug Entity Lifecycle Issues","text":""},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#finding-lost-entities","title":"Finding \"Lost\" Entities","text":"<p>If entity counts don't match expectations:</p> <pre><code>// Check stats for current counts\nconst stats = world.stats();\nconsole.log(`Alive: ${stats.aliveEntities}, Rows: ${stats.rows}`);\n\n// Iterate to find entities with specific components\nfor (const { e, c1 } of world.query(Position)) {\n    console.log(`Entity ${e.id} has Position:`, c1);\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#detecting-stale-entity-references","title":"Detecting Stale Entity References","text":"<pre><code>const entity = world.spawn();\nworld.despawn(entity);\n\n// Later...\nif (!world.isAlive(entity)) {\n    console.warn(\"Entity was despawned:\", entity);\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#tracking-pending-commands","title":"Tracking Pending Commands","text":"<p>The overlay shows \"Pending commands: true/false\". If commands aren't being applied:</p> <pre><code>// Commands are deferred\nworld.cmd().spawn();\nconsole.log(world.stats().pendingCommands); // true\n\n// After flush\nworld.flush();\nconsole.log(world.stats().pendingCommands); // false\n</code></pre>"},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#how-to-debug-archetype-fragmentation","title":"How to Debug Archetype Fragmentation","text":""},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#symptoms","title":"Symptoms","text":"<ul> <li>High archetype count relative to entity count</li> <li>Performance degradation over time</li> <li>Memory growth</li> </ul>"},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#diagnosis","title":"Diagnosis","text":"<pre><code>const stats = world.stats();\nconst ratio = stats.archetypes / stats.aliveEntities;\n\nif (ratio &gt; 0.1) {  // More than 1 archetype per 10 entities\n    console.warn(\"Possible archetype fragmentation\");\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#common-causes","title":"Common Causes","text":"<ol> <li> <p>Frequent component add/remove cycles <pre><code>// Bad: Creates new archetypes constantly\nworld.add(e, TempMarker, {});\nworld.remove(e, TempMarker);\n</code></pre></p> </li> <li> <p>Unique component combinations per entity <pre><code>// Bad: Each entity gets unique archetype\nworld.add(e, UniqueId, { id: generateUuid() });\nworld.add(e, CreatedAt, { time: Date.now() });\n</code></pre></p> </li> </ol>"},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#solutions","title":"Solutions","text":"<ul> <li>Use resources for singleton data</li> <li>Use component values instead of presence/absence for flags</li> <li>Batch component changes with <code>addMany()</code> / <code>removeMany()</code></li> </ul>"},{"location":"How-To%20Guides/How-to-Debug-Your-ECS-Application/#how-to-disable-the-overlay-in-production","title":"How to Disable the Overlay in Production","text":"<pre><code>// Option 1: Conditional creation\nconst world = new World();\nworld.setDebugging(process.env.NODE_ENV === \"development\");\n\n// Option 2: Destroy after creation\nconst world = new World();\nworld.destroyOverlay();\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/","title":"How to add InputState + AssetCache as Resources and use them in systems","text":""},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#goal","title":"Goal","text":"<p>Store Input state and an Asset cache as world Resources, then access them inside systems using <code>requireResource()</code>.</p>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#example-inputstateres","title":"Example InputStateRes","text":"<pre><code>export class InputStateRes\n{\n    public keysDown = new Set&lt;string&gt;();\n    public keysPressed = new Set&lt;string&gt;();   // pressed this frame\n    public keysReleased = new Set&lt;string&gt;();  // released this frame\n\n    public mouseX = 0;\n    public mouseY = 0;\n    public mouseButtonsDown = new Set&lt;number&gt;();\n    public mousePressed = new Set&lt;number&gt;();   // pressed this frame\n    public mouseReleased = new Set&lt;number&gt;();  // released this frame\n    public wheelDeltaY = 0;\n\n    beginFrame(): void\n    {\n        this.keysPressed.clear();\n        this.keysReleased.clear();\n        this.mousePressed.clear();\n        this.mouseReleased.clear();\n        this.wheelDeltaY = 0;\n    }\n\n    keyDown(code: string): void\n    {\n        if (!this.keysDown.has(code)) this.keysPressed.add(code);\n        this.keysDown.add(code);\n    }\n\n    keyUp(code: string): void\n    {\n        if (this.keysDown.has(code)) this.keysReleased.add(code);\n        this.keysDown.delete(code);\n    }\n\n    mouseMove(x: number, y: number): void {\n        this.mouseX = x;\n        this.mouseY = y;\n    }\n\n    mouseDown(btn: number): void\n    {\n        if (!this.mouseButtonsDown.has(btn)) this.mousePressed.add(btn);\n        this.mouseButtonsDown.add(btn);\n    }\n\n    mouseUp(btn: number): void\n    {\n        if (this.mouseButtonsDown.has(btn)) this.mouseReleased.add(btn);\n        this.mouseButtonsDown.delete(btn);\n    }\n\n    wheel(deltaY: number): void\n    {\n        this.wheelDeltaY += deltaY;\n    }\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#example-assetcacheres","title":"Example AssetCacheRes","text":"<pre><code>export class AssetCacheRes\n{\n    private images = new Map&lt;string, HTMLImageElement&gt;();\n    private pending = new Map&lt;string, Promise&lt;HTMLImageElement&gt;&gt;();\n\n    /** Loads once, dedupes concurrent calls, returns the same instance thereafter. */\n    public getImage(url: string): Promise&lt;HTMLImageElement&gt;\n    {\n        const ready = this.images.get(url);\n        if (ready) return Promise.resolve(ready);\n\n        const p = this.pending.get(url);\n        if (p) return p;\n\n        const promise = new Promise&lt;HTMLImageElement&gt;((resolve, reject) =&gt; {\n            const img = new Image();\n            img.onload = () =&gt; {\n                this.images.set(url, img);\n                this.pending.delete(url);\n                resolve(img);\n            };\n            img.onerror = (e) =&gt; {\n                this.pending.delete(url);\n                reject(e);\n            };\n            img.src = url;\n        });\n\n        this.pending.set(url, promise);\n        return promise;\n    }\n\n    /** Returns the image if already loaded; otherwise undefined. */\n    public peekImage(url: string): HTMLImageElement | undefined {\n        return this.images.get(url);\n    }\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#1-register-the-resources-at-startup","title":"1) Register the resources at startup","text":"<pre><code>world.initResource(InputStateRes, () =&gt; new InputStateRes());\nworld.initResource(AssetCacheRes, () =&gt; new AssetCacheRes());\n</code></pre> <p>That\u2019s the only \u201crequired\u201d setup. Everything else assumes these exist.</p>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#2-wire-dom-events-into-inputstateres","title":"2) Wire DOM events into <code>InputStateRes</code>","text":"<p>Attach listeners at once:</p> <pre><code>export function attachInput(world: WorldApi): void\n{\n    const input = world.requireResource(InputStateRes);\n\n    window.addEventListener(\"keydown\", e =&gt; input.keyDown(e.code));\n    window.addEventListener(\"keyup\",   e =&gt; input.keyUp(e.code));\n    window.addEventListener(\"mousemove\", e =&gt; input.mouseMove(e.clientX, e.clientY));\n    window.addEventListener(\"mousedown\", e =&gt; input.mouseDown(e.button));\n    window.addEventListener(\"mouseup\",   e =&gt; input.mouseUp(e.button));\n    window.addEventListener(\"wheel\",     e =&gt; input.wheel(e.deltaY), { passive: true });\n}\n</code></pre> <p>Call it after <code>initResource(...)</code>.</p>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#3-reset-pressedreleased-flags-once-per-frame","title":"3) Reset \u201cpressed/released\u201d flags once per frame","text":"<p>Add a phase/system that runs before gameplay update:</p> <pre><code>export function beginFrameSystem(w: WorldApi, _dt: number): void\n{\n    w.requireResource(InputStateRes).beginFrame();\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#4-read-input-from-systems","title":"4) Read input from systems","text":"<p>Example \u201cmove player\u201d system:</p> <pre><code>export function playerMoveSystem(w: WorldApi, dt: number): void\n{\n    const input = w.requireResource(InputStateRes);\n\n    let dx = 0, dy = 0;\n    if (input.keysDown.has(\"KeyW\")) dy -= 1;\n    if (input.keysDown.has(\"KeyS\")) dy += 1;\n    if (input.keysDown.has(\"KeyA\")) dx -= 1;\n    if (input.keysDown.has(\"KeyD\")) dx += 1;\n\n    const speed = 220;\n\n    for (const { c1: tr } of w.query(Transform, PlayerTag)) {\n        tr.x += dx * speed * dt;\n        tr.y += dy * speed * dt;\n    }\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#5-use-assetcacheres-in-a-render-system-deduped-async-loads","title":"5) Use <code>AssetCacheRes</code> in a render system (deduped async loads)","text":"<pre><code>export function renderSpritesSystem(ctx: CanvasRenderingContext2D)\n{\n    return (w: WorldApi, _dt: number): void =&gt; {\n        const assets = w.requireResource(AssetCacheRes);\n\n        for (const { c1: tr, c2: sp } of w.query(Transform, Sprite)) {\n            assets.getImage(sp.url).catch(() =&gt; {});\n            const img = assets.peekImage(sp.url);\n            if (!img) continue;\n\n            ctx.drawImage(img, tr.x, tr.y, sp.w, sp.h);\n        }\n    };\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#6-run-phases-in-order","title":"6) Run phases in order","text":"<p>Minimal schedule:</p> <pre><code>sched.add(world, \"beginFrame\", beginFrameSystem);\nsched.add(world, \"update\", playerMoveSystem);\nsched.add(world, \"render\", renderSpritesSystem(ctx));\n</code></pre> <p>Game loop:</p> <pre><code>sched.run(world, dt, [\"beginFrame\", \"update\", \"render\"]);\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#common-variations","title":"Common variations","text":""},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#optional-resource-usage","title":"Optional resource usage","text":"<p>If a resource is optional (debug/editor), use:</p> <pre><code>const dbg = w.getResource(DebugRes);\nif (dbg) dbg.enabled = true;\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#preload-assets-menuloading-screen","title":"Preload assets (menu/loading screen)","text":"<pre><code>await Promise.all(urls.map(u =&gt; world.requireResource(AssetCacheRes).getImage(u)));\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-remove-components-at-runtime/","title":"How to add/remove components at runtime","text":"<ol> <li>Define your component types (classes):</li> </ol> <pre><code>class Position { constructor(public x = 0, public y = 0) {} }\nclass Velocity { constructor(public x = 0, public y = 0) {} }\n</code></pre> <ol> <li>Add/remove immediately when you are not iterating a query:</li> </ol> <pre><code>const e = world.spawn();\nworld.add(e, Position, new Position(0, 0));\nworld.add(e, Velocity, new Velocity(1, 0));\n\n// Or add many at once\nconst z = world.spawn();\nworld.addMany(z, [new Position(0, 0), new Velocity(1, 0)])\n\nworld.remove(e, Velocity);\n</code></pre> <ol> <li>Add/remove during a query/system using deferred commands:</li> </ol> <pre><code>world.addSystem((w: any) =&gt; {\n  for (const { e, c1: pos } of w.query(Position)) {\n    if (pos.x &gt; 10) w.cmd().add(e, Velocity, new Velocity(1, 0));\n    if (pos.x &lt; 0)  w.cmd().remove(e, Velocity);\n  }\n});\n\n// Or remove many at once\nworld.addSystem((w: any) =&gt; {\n  for (const { e, c1: pos } of w.query(Position, Velocity)) {\n    if (pos.x &lt; 0)  w.cmd().removeMny(e, Position, Velocity);\n  }\n});\n\n// apply queued structural changes\nworld.flush();\n</code></pre>"},{"location":"How-To%20Guides/How-to-despawn-entities-safely/","title":"How to despawn entities safely","text":"<ol> <li>Despawn immediately when not iterating:</li> </ol> <pre><code>world.despawn(e);\n</code></pre> <ol> <li>Despawn during a query/system via <code>cmd()</code>:</li> </ol> <pre><code>world.addSystem((w: any) =&gt; {\n  for (const { e, c1: pos } of w.query(Position)) {\n    if (pos.x &gt; 10) w.cmd().despawn(e);\n  }\n});\n\n// apply despawns\nworld.flush();\n</code></pre> <ol> <li>Or rely on an end-of-frame flush:</li> </ol> <pre><code>world.update(dt); // runs systems, then flushes\n</code></pre>"},{"location":"How-To%20Guides/How-to-have-multiple-Worlds/","title":"How to have multiple Worlds (globe vs ground simulation)","text":"<ol> <li>Create two worlds:</li> </ol> <pre><code>const globeWorld = new World();\nconst groundWorld = new World();\n</code></pre> <ol> <li>Give each one its own schedule (recommended):</li> </ol> <pre><code>const globeSched  = new Schedule();\nconst groundSched = new Schedule();\n</code></pre> <ol> <li>Run both each frame (same <code>dt</code>):</li> </ol> <pre><code>globeSched.run(globeWorld, dt, [\"input\", \"sim\", \"render\"]);\ngroundSched.run(groundWorld, dt, [\"input\", \"sim\", \"render\"]);\n</code></pre> <ol> <li> <p>Share data explicitly between worlds (pick one):</p> </li> <li> <p>copy values at a known point (end of <code>sim</code>, start of other <code>sim</code>)</p> </li> <li>or have a \u201cbridge\u201d step in your outer loop that reads from one world and writes into the other (via normal <code>add/set</code> or via <code>cmd()</code> + <code>flush()</code>)</li> </ol>"},{"location":"How-To%20Guides/How-to-integrate-ECS-into-a-game-loop/","title":"How to integrate ECS into a game loop","text":""},{"location":"How-To%20Guides/How-to-integrate-ECS-into-a-game-loop/#option-a-use-worldupdatedt","title":"Option A \u2014 Use <code>world.update(dt)</code>","text":"<ol> <li>Register systems with <code>addSystem(...)</code></li> <li>In your loop call:</li> </ol> <pre><code>function tick(dt: number) {\n  world.update(dt); // runs systems, then flushes\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-integrate-ECS-into-a-game-loop/#option-b-use-schedule-phases-recommended-for-games","title":"Option B \u2014 Use <code>Schedule</code> phases (recommended for games)","text":"<ol> <li>Build a schedule (<code>input</code>, <code>sim</code>, <code>render</code>)</li> <li>In <code>requestAnimationFrame</code>:</li> </ol> <pre><code>let last = performance.now();\n\nfunction frame(now: number) {\n  const dt = (now - last) / 1000;\n  last = now;\n\n  sched.run(world, dt, [\"input\", \"sim\", \"render\"]); // flush between phases\n  renderer.render(scene, camera);\n\n  requestAnimationFrame(frame);\n}\n\nrequestAnimationFrame(frame);\n</code></pre>"},{"location":"How-To%20Guides/How-to-run-logic-conditionally/","title":"How to run logic conditionally","text":""},{"location":"How-To%20Guides/How-to-run-logic-conditionally/#option-a-guard-inside-the-system-simple","title":"Option A \u2014 Guard inside the system (simple)","text":"<ol> <li>Put a condition at the top:</li> </ol> <pre><code>let paused = false;\n\nworld.addSystem((w: any, dt: number) =&gt; {\n  if (paused) return;\n  for (const { c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x * dt;\n  }\n});\n</code></pre>"},{"location":"How-To%20Guides/How-to-run-logic-conditionally/#option-b-conditional-phases-skip-whole-groups","title":"Option B \u2014 Conditional phases (skip whole groups)","text":"<ol> <li>Maintain your phase list dynamically:</li> </ol> <pre><code>const base = [\"input\", \"sim\", \"render\"];\n\nfunction getPhases(paused: boolean) {\n  return paused ? [\"input\", \"render\"] : base;\n}\n\nsched.run(world, dt, getPhases(paused));\n</code></pre>"},{"location":"How-To%20Guides/How-to-run-logic-conditionally/#option-c-wrap-systems-reuse-predicates","title":"Option C \u2014 Wrap systems (reuse predicates)","text":"<ol> <li>Make a helper:</li> </ol> <pre><code>const runIf = (pred: () =&gt; boolean, fn: (w: any, dt: number) =&gt; void) =&gt;\n  (w: any, dt: number) =&gt; { if (pred()) fn(w, dt); };\n\nworld.addSystem(runIf(() =&gt; !paused, (w, dt) =&gt; {\n  for (const { c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x * dt;\n  }\n}));\n</code></pre>"},{"location":"How-To%20Guides/How-to-save-and-load-a-world/","title":"How to save and load a World","text":"<p>This guide shows a complete save/load flow:</p> <ol> <li>register snapshot codecs</li> <li>create a snapshot</li> <li>persist to JSON</li> <li>restore later</li> </ol>"},{"location":"How-To%20Guides/How-to-save-and-load-a-world/#1-define-data-componentsresources","title":"1) Define data components/resources","text":"<pre><code>class Position {\n  constructor(public x = 0, public y = 0) {}\n}\n\nclass Health {\n  constructor(public hp = 100) {}\n}\n\nclass GameState {\n  constructor(public wave = 1, public score = 0) {}\n}\n\ntype SpawnConfig = { interval: number };\nconst SpawnConfigToken = (() =&gt; ({ interval: 1.0 })) as ComponentCtor&lt;SpawnConfig&gt;;\n</code></pre>"},{"location":"How-To%20Guides/How-to-save-and-load-a-world/#2-register-snapshot-codecs-once-at-boot","title":"2) Register snapshot codecs once at boot","text":"<pre><code>import { SnapshotCodec, World, type ComponentCtor } from \"archetype-ecs-lib\";\n\nconst world = new World();\n\nconst positionCodec: SnapshotCodec&lt;Position, { x: number; y: number }&gt; = {\n  key: \"comp.position\",\n  serialize: (v) =&gt; ({ x: v.x, y: v.y }),\n  deserialize: (d) =&gt; new Position(d.x, d.y),\n};\n\nconst healthCodec: SnapshotCodec&lt;Health, { hp: number }&gt; = {\n  key: \"comp.health\",\n  serialize: (v) =&gt; ({ hp: v.hp }),\n  deserialize: (d) =&gt; new Health(d.hp),\n};\n\nconst gameStateCodec: SnapshotCodec&lt;GameState, { wave: number; score: number }&gt; = {\n  key: \"res.game-state\",\n  serialize: (v) =&gt; ({ wave: v.wave, score: v.score }),\n  deserialize: (d) =&gt; new GameState(d.wave, d.score),\n};\n\nconst spawnConfigCodec: SnapshotCodec&lt;SpawnConfig, { interval: number }&gt; = {\n  key: \"res.spawn-config\",\n  serialize: (v) =&gt; ({ interval: v.interval }),\n  deserialize: (d) =&gt; ({ interval: d.interval }),\n};\n\nworld.registerComponentSnapshot(Position, positionCodec);\nworld.registerComponentSnapshot(Health, healthCodec);\nworld.registerResourceSnapshot(GameState, gameStateCodec);\nworld.registerResourceSnapshot(SpawnConfigToken, spawnConfigCodec);\n</code></pre> <p>Only registered types are persisted.</p>"},{"location":"How-To%20Guides/How-to-save-and-load-a-world/#3-create-a-snapshot-and-persist-it","title":"3) Create a snapshot and persist it","text":"<pre><code>const snapshot = world.snapshot();\nconst json = JSON.stringify(snapshot);\n\nlocalStorage.setItem(\"save-slot-1\", json);\n</code></pre>"},{"location":"How-To%20Guides/How-to-save-and-load-a-world/#4-restore-from-persisted-json","title":"4) Restore from persisted JSON","text":"<pre><code>const raw = localStorage.getItem(\"save-slot-1\");\nif (raw) {\n  const snapshot = JSON.parse(raw);\n  world.restore(snapshot);\n}\n</code></pre> <p><code>restore()</code> will clear runtime queues (pending commands/events) and reconstruct persisted entity/resource state.</p>"},{"location":"How-To%20Guides/How-to-save-and-load-a-world/#5-common-pattern-baseline-quick-save","title":"5) Common pattern: baseline + quick save","text":"<pre><code>const baseline = world.snapshot(); // after bootstrap\nlet quickSave: ReturnType&lt;World[\"snapshot\"]&gt; | null = null;\n\nfunction doQuickSave() {\n  quickSave = world.snapshot();\n}\n\nfunction doQuickLoad() {\n  if (quickSave) world.restore(quickSave);\n}\n\nfunction resetRun() {\n  world.restore(baseline);\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-save-and-load-a-world/#6-important-checks","title":"6) Important checks","text":"<ul> <li>Register codecs before calling <code>restore(...)</code>.</li> <li>Keep codec keys stable across versions.</li> <li>Ensure codec output is JSON-safe if you store saves as JSON.</li> <li>Re-register systems/schedules in app boot code (they are runtime behavior, not snapshot data).</li> </ul>"},{"location":"How-To%20Guides/How-to-split-logic-into-multiple-system-phases/","title":"How to split logic into multiple system phases","text":"<ol> <li>Create a <code>Schedule</code> and register systems by phase name:</li> </ol> <pre><code>const sched = new Schedule();\n\nsched\n  .add(world, \"input\", (w: any) =&gt; { /* ... */ })\n  .add(world, \"sim\",   (w: any, dt: number) =&gt; { /* ... */ })\n  .add(world, \"render\",(w: any) =&gt; { /* ... */ });\n</code></pre> <ol> <li>Define phase order:</li> </ol> <pre><code>const phases = [\"input\", \"sim\", \"render\"];\n</code></pre> <ol> <li>Run it each tick (flush happens after each phase):</li> </ol> <pre><code>sched.run(world, dt, phases);\n</code></pre>"},{"location":"How-To%20Guides/How-to-use-ECS-alongside-Three.js/","title":"How to use ECS alongside Three.js","text":""},{"location":"How-To%20Guides/How-to-use-ECS-alongside-Three.js/#pattern-ecs-owns-state-threejs-owns-objects","title":"Pattern: ECS owns state, Three.js owns objects","text":"<ol> <li>Keep Three.js objects in a map (outside ECS):</li> </ol> <pre><code>const meshes = new Map&lt;number, THREE.Object3D&gt;(); // key = entity.id\n</code></pre> <ol> <li>Add components for simulation and \u201crender tag\u201d:</li> </ol> <pre><code>class Position { constructor(public x=0, public y=0, public z=0) {} }\nclass Renderable { constructor(public kind: \"cube\" | \"ship\" = \"cube\") {} }\n</code></pre> <ol> <li>Spawn entities in ECS:</li> </ol> <pre><code>const e = world.spawnMany(\n  new Position(0, 0, 0),\n  new Renderable(\"cube\")\n)\n</code></pre> <ol> <li> <p>Create a render-sync system in a <code>render</code> phase:</p> </li> <li> <p>create missing meshes</p> </li> <li>update transforms</li> <li>remove meshes for despawned entities (see step 5)</li> </ol> <pre><code>sched.add(world, \"render\", (w: any) =&gt; {\n  for (const { e, c1: pos, c2: rend } of w.query(Position, Renderable)) {\n    let obj = meshes.get(e.id);\n    if (!obj) {\n      obj = makeObjectFromKind(rend.kind); // your factory\n      scene.add(obj);\n      meshes.set(e.id, obj);\n    }\n    obj.position.set(pos.x, pos.y, pos.z);\n  }\n});\n</code></pre> <ol> <li> <p>Despawn visually after flush:</p> </li> <li> <p>despawn in ECS via <code>cmd().despawn(e)</code></p> </li> <li>after the flush boundary, remove from <code>meshes</code> if it\u2019s gone</li> </ol> <p>A simple cleanup pass each frame:</p> <pre><code>for (const [id, obj] of meshes) {\n  // if you track alive entities externally, remove when not alive anymore.\n  // (One common approach: record seen IDs during the render query and remove the rest.)\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/","title":"How to use Events to decouple systems across phases","text":""},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/#goal","title":"Goal","text":"<p>Emit events in one phase and consume them in a later phase, without coupling systems directly.</p> <p>This guide assumes you already have a <code>Schedule</code> with multiple phases and that the schedule swaps events between phases.</p>"},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/#1-define-event-types","title":"1) Define event types","text":"<p>Use classes (recommended) or token keys.</p> <pre><code>export class DamageEvent {\n    constructor(public target: Entity, public amount: number) {}\n}\n\nexport class PlaySoundEvent {\n    constructor(public id: string) {}\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/#2-emit-events-from-a-producer-system","title":"2) Emit events from a producer system","text":"<p>Example: gameplay system emits damage + sound.</p> <pre><code>function combatSystem(w: WorldApi, _dt: number) {\n    // ... detect hit\n    w.emit(DamageEvent, new DamageEvent(target, 10));\n    w.emit(PlaySoundEvent, new PlaySoundEvent(\"hit\"));\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/#3-consume-events-in-the-next-phase","title":"3) Consume events in the next phase","text":"<p>Place a consumer in the next phase (phase-scoped delivery):</p> <pre><code>function applyDamageSystem(w: WorldApi, _dt: number) {\n    w.drainEvents(DamageEvent, (ev) =&gt; {\n        const hp = w.get(ev.target, Health);\n        if (!hp) return;\n        hp.value -= ev.amount;\n    });\n}\n</code></pre> <p>Schedule order:</p> <pre><code>schedule.add(world, \"update\", combatSystem);\nschedule.add(world, \"afterUpdate\", applyDamageSystem);\n</code></pre>"},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/#4-deliver-events-to-late-phases-forwarding-pattern","title":"4) Deliver events to late phases (forwarding pattern)","text":"<p>With phase-scoped delivery, an event emitted in <code>update</code> is visible in <code>afterUpdate</code>. If you want it to reach <code>audio</code> several phases later, forward it:</p> <pre><code>function forwardSoundSystem(w: WorldApi, _dt: number) {\n    w.drainEvents(PlaySoundEvent, (ev) =&gt; {\n        w.emit(PlaySoundEvent, ev); // re-emit for the next phase\n    });\n}\n\nfunction audioSystem(w: WorldApi, _dt: number) {\n    w.drainEvents(PlaySoundEvent, (ev) =&gt; {\n        console.log(\"[audio] play:\", ev.id);\n    });\n}\n</code></pre> <p>Example pipeline:</p> <pre><code>schedule.add(world, \"update\", combatSystem);            // emits PlaySoundEvent\nschedule.add(world, \"afterUpdate\", forwardSoundSystem); // forwards -&gt; render\nschedule.add(world, \"afterRender\", forwardSoundSystem); // forwards -&gt; audio\nschedule.add(world, \"audio\", audioSystem);              // consumes\n</code></pre>"},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/#5-use-eventskeyvalues-for-read-only-inspection","title":"5) Use <code>events(key).values()</code> for read-only inspection","text":"<p>If you need to check what\u2019s readable without consuming it:</p> <pre><code>const pending = w.events(DamageEvent).values();\nif (pending.length &gt; 0) {\n    // inspect (do not store array reference)\n}\n</code></pre> <p>Prefer <code>drainEvents</code> for typical processing.</p>"},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/#6-clear-events-when-resetting-state","title":"6) Clear events when resetting state","text":"<p>To clear one type:</p> <pre><code>w.clearEvents(DamageEvent);\n</code></pre> <p>To clear all readable event buffers:</p> <pre><code>w.clearEvents();\n</code></pre>"},{"location":"Reference/archetypes/","title":"Archetypes","text":""},{"location":"Reference/archetypes/#purpose","title":"Purpose","text":"<p>An archetype is an internal storage \u201ctable\u201d that groups together all entities sharing the same set of component types. Archetypes are the core performance mechanism of this ECS: queries match archetypes first, then iterate rows inside them. </p>"},{"location":"Reference/archetypes/#storage-model","title":"Storage model","text":""},{"location":"Reference/archetypes/#table-layout-soa","title":"Table layout (SoA)","text":"<p>Archetypes store component data in Structure of Arrays (SoA) form:</p> <ul> <li>one column per component type</li> <li>each entity occupies a row across all columns </li> </ul> <p>This is the reason queries are efficient: iteration is over dense arrays rather than scattered objects. </p>"},{"location":"Reference/archetypes/#archetype-membership","title":"Archetype membership","text":""},{"location":"Reference/archetypes/#structural-changes-move-entities-between-archetypes","title":"Structural changes move entities between archetypes","text":"<p>When an entity\u2019s component set changes, the entity moves to a different archetype:</p> <ul> <li><code>add(e, Ctor, value)</code> is structural and may move the entity to another archetype </li> <li><code>remove(e, Ctor)</code> is structural and may move the entity to another archetype </li> </ul> <p>Non-structural updates do not change archetype membership:</p> <ul> <li><code>set(e, Ctor, value)</code> updates the value but does not change the component set </li> </ul>"},{"location":"Reference/archetypes/#queries-and-archetypes","title":"Queries and archetypes","text":""},{"location":"Reference/archetypes/#archetype-filtering","title":"Archetype filtering","text":"<p><code>query(...ctors)</code> only iterates archetypes that contain all required component columns, then yields matching entity rows. </p>"},{"location":"Reference/archetypes/#query-row-shape","title":"Query row shape","text":"<p>For <code>query(A, B, C)</code>, the yielded row contains:</p> <ul> <li><code>e</code> (entity handle)</li> <li><code>c1</code>, <code>c2</code>, <code>c3</code> component values in the same order as the ctor arguments </li> </ul>"},{"location":"Reference/archetypes/#safety-constraints","title":"Safety constraints","text":""},{"location":"Reference/archetypes/#structural-changes-during-iteration","title":"Structural changes during iteration","text":"<p>While iterating queries (and generally while systems run), doing structural changes directly can throw. The recommended pattern is:</p> <ul> <li>enqueue structural changes via <code>world.cmd()</code></li> <li>apply them via <code>world.flush()</code> (or at the end of <code>world.update(dt)</code>) </li> </ul> <p>This matters because structural changes imply archetype moves. </p>"},{"location":"Reference/archetypes/#visibility-public-api","title":"Visibility / Public API","text":"<p>Archetypes are an internal mechanism (the public exports are <code>Types</code>, <code>TypeRegistry</code>, <code>Commands</code>, <code>World</code>, <code>Schedule</code>). Users interact with archetypes only indirectly through <code>World</code> operations and <code>query()</code>. </p>"},{"location":"Reference/commands/","title":"Commands","text":""},{"location":"Reference/commands/#purpose","title":"Purpose","text":"<p><code>Commands</code> is a deferred structural change buffer. It lets you enqueue structural operations (spawn/despawn/add/remove) while iterating queries or running systems, then apply them later via <code>world.flush()</code> (or at the end of <code>world.update(dt)</code>). </p>"},{"location":"Reference/commands/#how-to-obtain-a-commands-buffer","title":"How to obtain a <code>Commands</code> buffer","text":""},{"location":"Reference/commands/#worldcmd-commands","title":"<code>world.cmd(): Commands</code>","text":"<p><code>World.cmd()</code> returns a <code>Commands</code> instance you can use to enqueue operations. </p> <p>Typical usage: </p> <pre><code>const cmd = world.cmd();\n\ncmd.spawn((e) =&gt; {\n    cmd.add(e, Position, new Position(0, 0));\n});\n\ncmd.add(entity, Velocity, new Velocity(1, 0));\ncmd.remove(entity, Velocity);\ncmd.despawn(entity);\n\nworld.flush();\n</code></pre>"},{"location":"Reference/commands/#supported-operations","title":"Supported operations","text":"<p>The command buffer supports these operations (as documented by the project): </p>"},{"location":"Reference/commands/#spawninit","title":"<code>spawn(init?)</code>","text":"<p>Enqueues creation of a new entity.</p> <ul> <li><code>init?: (e: Entity) =&gt; void</code> is an optional callback invoked with the spawned entity, typically used to enqueue <code>add()</code> calls for initial components. </li> </ul>"},{"location":"Reference/commands/#spawnbundleitems-componentctorbundleitem","title":"<code>spawnBundle(...items: ComponentCtorBundleItem[])</code>","text":"<p>Queues the creation of a new entity, along with its initial components, and applies everything on the next flush (within the same flush cycle).</p> <ul> <li><code>...items: ComponentCtorBundleItem[]</code> is the list of components to add to the newly created entity.</li> <li>Internally, it iterates over the items and calls <code>add(e, ctor, value)</code> for each component.</li> </ul>"},{"location":"Reference/commands/#despawne-entity","title":"<code>despawn(e: Entity)</code>","text":"<p>Enqueues removal of an entity. </p>"},{"location":"Reference/commands/#despawnbundleentities-entity","title":"<code>despawnBundle(entities: Entity[])</code>","text":"<p>Enqueues the destruction of multiple entities. The actual removals are applied when commands are flushed.</p> <ul> <li><code>entities: Entity[]</code> is the list of entities to despawn.</li> <li>Internally, it iterates over the array and calls <code>despawn(e)</code> for each entity.</li> </ul>"},{"location":"Reference/commands/#adde-ctor-value","title":"<code>add(e, ctor, value)</code>","text":"<p>Enqueues adding a component to an entity. This is a structural change (it may move the entity between archetypes), which is why it is commonly deferred. </p>"},{"location":"Reference/commands/#addbundlee-entity-items-componentctorbundleitem","title":"<code>addBundle(e: Entity, ...items: ComponentCtorBundleItem[])</code>","text":"<p>Enqueues adding multiple components to an existing entity. All component adds are applied on flush.</p> <ul> <li><code>e: Entity</code> is the target entity.</li> <li><code>...items: ComponentCtorBundleItem[]</code> is the list of components to add.</li> <li>Internally, it loops through the items and calls <code>add(e, ctor, value)</code> for each component.</li> </ul>"},{"location":"Reference/commands/#removee-ctor","title":"<code>remove(e, ctor)</code>","text":"<p>Enqueues removing a component from an entity. This is also a structural change. </p>"},{"location":"Reference/commands/#removebundlee-entity-ctors-componentctorany","title":"<code>removeBundle(e: Entity, ...ctors: ComponentCtor&lt;any&gt;[])</code>","text":"<p>Enqueues removal of multiple component types from an entity. The removals are applied on flush.</p> <ul> <li><code>e: Entity</code> is the target entity.</li> <li><code>...ctors: ComponentCtor&lt;any&gt;[]</code> is the list of component constructors (types) to remove.</li> <li>Internally, it loops through the ctors and calls <code>remove(e, ctor)</code> for each one.</li> </ul>"},{"location":"Reference/commands/#applying-commands","title":"Applying commands","text":""},{"location":"Reference/commands/#worldflush-void","title":"<code>world.flush(): void</code>","text":"<p>Applies all queued commands. <code>World.update(dt)</code> also flushes automatically at the end of the frame. </p>"},{"location":"Reference/commands/#with-schedule","title":"With <code>Schedule</code>","text":"<p>When using <code>Schedule</code>, <code>world.flush()</code> is called after each phase, creating deterministic \u201cphase barriers\u201d for command application. </p>"},{"location":"Reference/commands/#safety-rule","title":"Safety rule","text":"<p>Direct structural operations can throw while iterating queries or running systems. The intended pattern is:</p> <ul> <li>enqueue structural changes with <code>world.cmd()</code></li> <li>apply them with <code>world.flush()</code> (or let <code>update()</code> do it) </li> </ul>"},{"location":"Reference/components/","title":"Components","text":""},{"location":"Reference/components/#purpose","title":"Purpose","text":"<p>A component is a unit of data attached to an <code>Entity</code>. In this ECS, components are stored in archetypes (tables) using a Structure-of-Arrays (SoA) layout: one column per component type. </p>"},{"location":"Reference/components/#component-type-key","title":"Component \u201ctype\u201d (key)","text":"<p>A component type is identified by a constructor (typically a class):</p> <pre><code>class Position { constructor(public x = 0, public y = 0) {} }\nclass Velocity { constructor(public x = 0, public y = 0) {} }\n</code></pre> <p>Any class used as a type key is considered a valid component type. </p>"},{"location":"Reference/components/#typeid-mapping","title":"TypeId mapping","text":"<p>Internally, component constructors are mapped to a stable numeric <code>TypeId</code> via <code>typeId()</code>.  <code>TypeId</code> assignment is process-local and based on constructor identity (via <code>WeakMap</code>). </p>"},{"location":"Reference/components/#component-value","title":"Component \u201cvalue\u201d","text":"<p>The component value is the actual instance stored in the archetype column (e.g. <code>new Position(1,2)</code>).</p> <ul> <li>Values are stored per-archetype, per-column (SoA) </li> <li>Queries return direct references to these values (you mutate them in place)</li> </ul>"},{"location":"Reference/components/#world-operations-on-components","title":"World operations on components","text":"<p>All component operations are done through <code>World</code> using the component constructor as the key. </p>"},{"location":"Reference/components/#presence-access","title":"Presence / access","text":"<ul> <li><code>has(e, Ctor): boolean</code> </li> <li><code>get(e, Ctor): T | undefined</code> </li> </ul>"},{"location":"Reference/components/#update-non-structural","title":"Update (non-structural)","text":"<ul> <li><code>set(e, Ctor, value): void</code>   Requires the component to exist; otherwise throws. </li> </ul>"},{"location":"Reference/components/#structural-changes","title":"Structural changes","text":"<p>These may move the entity between archetypes:</p> <ul> <li><code>add(e, Ctor, value): void</code> </li> <li><code>remove(e, Ctor): void</code> </li> </ul>"},{"location":"Reference/components/#queries-and-component-ordering","title":"Queries and component ordering","text":"<p><code>world.query(A, B, C)</code> yields rows shaped like:</p> <ul> <li><code>e</code>: the entity</li> <li><code>c1</code>, <code>c2</code>, <code>c3</code>: component values in the same order as the ctor arguments </li> </ul> <p>Example:</p> <pre><code>for (const { e, c1: pos, c2: vel } of world.query(Position, Velocity)) { }\n</code></pre>"},{"location":"Reference/components/#safety-rules-during-iteration","title":"Safety rules during iteration","text":"<p>While iterating a query (or while systems are running), direct structural changes can throw. Use deferred commands instead:</p> <ul> <li>enqueue via <code>world.cmd()</code></li> <li>apply via <code>world.flush()</code> </li> </ul>"},{"location":"Reference/debugging/","title":"Debugging &amp; Profiling Reference","text":""},{"location":"Reference/debugging/#statsoverlayoptions","title":"StatsOverlayOptions","text":"<p>Configuration options passed to <code>World</code> constructor.</p> <pre><code>type StatsOverlayOptions = Readonly&lt;{\n    parent?: HTMLElement;\n    left?: number;\n    top?: number;\n    width?: number;\n    height?: number;\n    targetFrameMs?: number;\n    slowFrameMs?: number;\n    maxSamples?: number;\n}&gt;;\n</code></pre> Option Type Default Description <code>parent</code> <code>HTMLElement</code> <code>document.body</code> Container element for the overlay <code>left</code> <code>number</code> <code>8</code> Left offset in pixels <code>top</code> <code>number</code> <code>8</code> Top offset in pixels <code>width</code> <code>number</code> <code>320</code> Canvas width in pixels <code>height</code> <code>number</code> <code>80</code> Canvas height in pixels <code>targetFrameMs</code> <code>number</code> <code>16.67</code> Target frame time (white line) <code>slowFrameMs</code> <code>number</code> <code>20</code> Slow frame threshold (red bars) <code>maxSamples</code> <code>number</code> <code>240</code> Number of frames in history graph"},{"location":"Reference/debugging/#worldstats","title":"WorldStats","text":"<p>Returned by <code>world.stats()</code>.</p> <pre><code>type WorldStats = Readonly&lt;{\n    aliveEntities: number;\n    archetypes: number;\n    rows: number;\n    systems: number;\n    resources: number;\n    eventChannels: number;\n    pendingCommands: boolean;\n    frame: number;\n    dt: number;\n    frameMs: number;\n    phaseMs: Record&lt;string, number&gt;;\n    systemMs: Record&lt;string, number&gt;;\n}&gt;;\n</code></pre> Field Description <code>aliveEntities</code> Count of non-despawned entities <code>archetypes</code> Number of unique component combinations <code>rows</code> Total rows across all archetype tables <code>systems</code> Number of registered systems <code>resources</code> Number of stored resources <code>eventChannels</code> Number of active event channels <code>pendingCommands</code> Whether command queue has pending operations <code>frame</code> Current frame counter <code>dt</code> Delta time passed to last <code>update()</code> call <code>frameMs</code> Wall-clock time of last frame <code>phaseMs</code> Per-phase timing breakdown <code>systemMs</code> Per-system timing breakdown"},{"location":"Reference/debugging/#worldstatshistory","title":"WorldStatsHistory","text":"<p>Returned by <code>world.statsHistory()</code>.</p> <pre><code>type WorldStatsHistory = Readonly&lt;{\n    capacity: number;\n    size: number;\n    dt: ReadonlyArray&lt;number&gt;;\n    frameMs: ReadonlyArray&lt;number&gt;;\n    phaseMs: Record&lt;string, ReadonlyArray&lt;number&gt;&gt;;\n    systemMs: Record&lt;string, ReadonlyArray&lt;number&gt;&gt;;\n}&gt;;\n</code></pre> Field Description <code>capacity</code> Maximum frames stored <code>size</code> Current number of frames stored <code>dt</code> Rolling history of delta times <code>frameMs</code> Rolling history of frame times <code>phaseMs</code> Per-phase timing history <code>systemMs</code> Per-system timing history"},{"location":"Reference/debugging/#profiling-api","title":"Profiling API","text":""},{"location":"Reference/debugging/#worldsetprofilingenabledenabled-boolean","title":"<code>world.setProfilingEnabled(enabled: boolean)</code>","text":"<p>Enable or disable a timing collection. When disabled, <code>frameMs</code>, <code>phaseMs</code>, and <code>systemMs</code> will be <code>0</code>.</p>"},{"location":"Reference/debugging/#worldsetprofilinghistorysizeframes-number","title":"<code>world.setProfilingHistorySize(frames: number)</code>","text":"<p>Set the rolling history capacity. Existing history is trimmed if reduced.</p>"},{"location":"Reference/debugging/#overlay-api","title":"Overlay API","text":""},{"location":"Reference/debugging/#worldsetdebuggingenabled-boolean","title":"<code>world.setDebugging(enabled: boolean)</code>","text":"<p>Enable or disable the stats overlay. When disabled, the method <code>world.destroyOverlay()</code> is called.</p>"},{"location":"Reference/debugging/#worlddestroyoverlay","title":"<code>world.destroyOverlay()</code>","text":"<p>Remove the stats overlay from the DOM and clean up event listeners.</p>"},{"location":"Reference/debugging/#worldupdateoverlaystats-history","title":"<code>world.updateOverlay(stats, history)</code>","text":"<p>Manually trigger an overlay render. Called automatically by <code>world.update()</code> and <code>schedule.run()</code>.</p>"},{"location":"Reference/debugging/#overlay-ui-elements","title":"Overlay UI Elements","text":"Element Function Title bar Drag to reposition overlay / button Toggle console debug logging \u2212/+ button Collapse/expand overlay content Graph Frame time history visualization Legend Target line, OK bars, Slow bars thresholds"},{"location":"Reference/entity/","title":"Entity","text":""},{"location":"Reference/entity/#purpose","title":"Purpose","text":"<p>An Entity is a lightweight, opaque handle used to reference rows stored inside archetypes. It is not the data itself (components hold the data). </p>"},{"location":"Reference/entity/#type","title":"Type","text":"<pre><code>type Entity = { id: number; gen: number };\n</code></pre> <ul> <li><code>id</code>: stable numeric slot identifier</li> <li><code>gen</code>: generation counter used to detect stale handles after despawn / reuse </li> </ul>"},{"location":"Reference/entity/#semantics","title":"Semantics","text":""},{"location":"Reference/entity/#identity","title":"Identity","text":"<p>An entity handle is considered valid only if both:</p> <ul> <li>the <code>id</code> refers to an allocated slot</li> <li>the <code>gen</code> matches the current generation for that slot </li> </ul>"},{"location":"Reference/entity/#stale-handles","title":"Stale handles","text":"<p>If an entity is despawned and the <code>id</code> is later reused, the <code>gen</code> will differ. This prevents accidentally operating on \u201cthe new entity that reused the same id\u201d. </p>"},{"location":"Reference/entity/#where-entities-come-from","title":"Where entities come from","text":"<ul> <li><code>world.spawn()</code> returns an <code>Entity</code> handle </li> <li><code>world.query(...)</code> yields rows that include <code>e: Entity</code> </li> </ul>"},{"location":"Reference/entity/#where-entities-are-used","title":"Where entities are used","text":"<p>Entities are passed into World operations (examples):</p> <ul> <li>lifecycle: <code>despawn(e)</code></li> <li>components: <code>add(e, Ctor, value)</code>, <code>remove(e, Ctor)</code>, <code>get(e, Ctor)</code>, <code>set(e, Ctor, value)</code> </li> <li>commands (deferred): <code>cmd.despawn(e)</code>, <code>cmd.add(e, ...)</code>, <code>cmd.remove(e, ...)</code> </li> </ul>"},{"location":"Reference/entity/#related-behavior","title":"Related behavior","text":""},{"location":"Reference/entity/#safety-during-iteration","title":"Safety during iteration","text":"<p>When iterating query results (which contain <code>e: Entity</code>), structural changes should be deferred via commands and applied with <code>flush()</code>. </p>"},{"location":"Reference/events/","title":"Reference: Events API","text":""},{"location":"Reference/events/#overview","title":"Overview","text":"<p>Events are typed, transient messages used to decouple systems. They are stored per event type in double-buffered channels:</p> <ul> <li><code>emit()</code> appends to the write buffer (current phase)</li> <li><code>drain()</code> / <code>values()</code> read from the read buffer (previous phase)</li> <li>At each phase boundary, <code>world.swapEvents()</code> swaps buffers so events become visible to the next phase</li> </ul>"},{"location":"Reference/events/#key-type","title":"Key type","text":"<p>Event channels are keyed by <code>ComponentCtor&lt;T&gt;</code> (same as components/resources). Keys are compared by identity.</p>"},{"location":"Reference/events/#eventchannelt-eventsts","title":"<code>EventChannel&lt;T&gt;</code> (Events.ts)","text":""},{"location":"Reference/events/#emitev-t-void","title":"<code>emit(ev: T): void</code>","text":"<p>Appends an event to the write buffer for the current phase.</p> <p>Notes</p> <ul> <li>Emitted events are not readable in the same phase</li> <li>They become readable after the next <code>swapBuffers()</code> / <code>world.swapEvents()</code></li> </ul>"},{"location":"Reference/events/#drainfn-ev-t-void-void","title":"<code>drain(fn: (ev: T) =&gt; void): void</code>","text":"<p>Iterates all readable events (read buffer) and then clears that buffer.</p> <p>Semantics</p> <ul> <li>Reads only events emitted in the previous phase</li> <li>After <code>drain</code>, <code>count()</code> becomes <code>0</code></li> </ul> <p>Performance</p> <ul> <li>No iterator allocations; uses indexed loop</li> <li>Clears with <code>length = 0</code></li> </ul>"},{"location":"Reference/events/#values-readonly-t","title":"<code>values(): readonly T[]</code>","text":"<p>Returns a read-only view of the read buffer.</p> <p>Semantics</p> <ul> <li>Snapshot is valid until the next boundary swap</li> <li>Do not store the returned array long-term</li> </ul>"},{"location":"Reference/events/#count-number","title":"<code>count(): number</code>","text":"<p>Returns the number of readable events currently in the read buffer.</p>"},{"location":"Reference/events/#clear-void","title":"<code>clear(): void</code>","text":"<p>Clears the read buffer only.</p>"},{"location":"Reference/events/#clearall-void","title":"<code>clearAll(): void</code>","text":"<p>Clears both read and write buffers.</p>"},{"location":"Reference/events/#swapbuffers-void-internal","title":"<code>swapBuffers(): void</code> (internal)","text":"<p>Swaps read/write buffers and clears the new write buffer.</p> <p>Semantics</p> <ul> <li>Makes events emitted in the previous phase readable now</li> <li>Drops any undrained events from the prior read buffer at the next swap (phase-scoped delivery)</li> </ul>"},{"location":"Reference/events/#delivery-model-summary-phase-scoped","title":"Delivery model summary (phase-scoped)","text":"<p>If you run phases:</p> <p><code>A -&gt; B -&gt; C</code></p> <p>Events emitted in A are readable in B. If not drained in B, they are dropped at <code>B -&gt; C</code> swap.</p>"},{"location":"Reference/queries/","title":"Query \u2014 Reference","text":""},{"location":"Reference/queries/#purpose","title":"Purpose","text":"<p>A Query iterates all entities that have all required component types, efficiently by scanning only the matching archetypes (tables). </p>"},{"location":"Reference/queries/#api","title":"API","text":""},{"location":"Reference/queries/#worldqueryctors-componentctorany-iterableany","title":"<code>world.query(...ctors: ComponentCtor&lt;any&gt;[]): Iterable&lt;any&gt;</code>","text":"<p><code>ctors</code> is a list of component constructors (types) you want to require.</p> <pre><code>for (const row of world.query(Position, Velocity)) {\n  // ...\n}\n</code></pre> <p>Queries yield rows shaped like: </p> <ul> <li><code>e</code>: the <code>Entity</code></li> <li><code>c1</code>, <code>c2</code>, <code>c3</code>, \u2026: component values in the same order as the <code>ctors</code> arguments</li> </ul> <p>So <code>query(A, B, C)</code> yields <code>{ e, c1: A, c2: B, c3: C }</code>.</p>"},{"location":"Reference/queries/#row-mapping-and-ordering","title":"Row mapping and ordering","text":""},{"location":"Reference/queries/#deterministic-component-fields","title":"Deterministic component fields","text":"<p>The mapping is positional:</p> <ul> <li><code>query(A)</code> \u2192 <code>{ e, c1 }</code></li> <li><code>query(A, B)</code> \u2192 <code>{ e, c1, c2 }</code></li> <li><code>query(A, B, C)</code> \u2192 <code>{ e, c1, c2, c3 }</code></li> </ul> <p>And <code>cN</code> always corresponds to the Nth constructor you passed. </p>"},{"location":"Reference/queries/#example","title":"Example","text":"<pre><code>for (const { e, c1: pos, c2: vel } of world.query(Position, Velocity)) {\n    pos.x += vel.x;\n    pos.y += vel.y;\n\n    // Safe structural change: defer it\n    if (pos.x &gt; 10) world.cmd().despawn(e);\n}\n</code></pre> <p>This pattern is recommended explicitly for queries.</p>"},{"location":"Reference/queries/#worldquerytablesctors-componentctorany-iterableany","title":"<code>world.queryTables(...ctors: ComponentCtor&lt;any&gt;[]): Iterable&lt;any&gt;</code>","text":"<p><code>ctors</code> is a list of component constructors (types) you want to require.</p> <pre><code>for (const table of world.queryTables(Position, Velocity)) {\n  // ...\n}\n</code></pre> <p>Queries yield one item per matching archetype (table) (SoA columns + entity array):</p> <ul> <li><code>entities</code>: <code>Entity[]</code> (row-aligned with all columns)</li> <li><code>c1</code>, <code>c2</code>, <code>c3</code>, \u2026: component columns (<code>T[]</code>) in the same order as <code>ctors</code></li> </ul> <p>So <code>queryTables(A, B, C)</code> yields <code>{ entities, c1: A[], c2: B[], c3: C[] }</code>.</p>"},{"location":"Reference/queries/#why-querytables","title":"Why <code>queryTables</code>?","text":"<p>Use this when you want fewer allocations and more cache-friendly loops:</p> <ul> <li>you iterate columns + indices instead of creating one <code>{e, c1, ...}</code> object per entity</li> <li>you can batch work per archetype</li> </ul> <p>Example: <pre><code>for (const { entities, c1: pos, c2: vel } of world.queryTables(Position, Velocity)) {\n  for (let i = 0; i &lt; entities.length; i++) {\n    pos[i]!.x += vel[i]!.dx;\n    pos[i]!.y += vel[i]!.dy;\n  }\n}\n</code></pre></p>"},{"location":"Reference/queries/#worldqueryeachctorsandfn-void","title":"<code>world.queryEach(...ctorsAndFn): void</code>","text":"<p>Callback-based query: no generator, no yielded row objects.</p> <pre><code>world.queryEach(Position, (e, pos) =&gt; {\n  // ...\n});\n\nworld.queryEach(Position, Velocity, (e, pos, vel) =&gt; {\n  // ...\n});\n</code></pre> <p><code>queryEach(A, B, ...)</code> calls <code>fn(e, c1, c2, ...)</code> where <code>cN</code> matches the Nth constructor argument.</p> <p>So <code>queryEach(A, B, C, fn)</code> calls <code>fn(e, A, B, C)</code> in that order.</p>"},{"location":"Reference/queries/#why-queryeach","title":"Why <code>queryEach</code>?","text":"<p>Use this when you want the simplest \u201cdo work per entity\u201d loop without generator overhead: <pre><code>world.queryEach(Position, Velocity, (e, pos, vel) =&gt; {\n  pos.x += vel.dx;\n  pos.y += vel.dy;\n\n  // Safe structural change: defer it\n  if (pos.x &gt; 10) world.cmd().despawn(e);\n});\n</code></pre></p>"},{"location":"Reference/queries/#safety-rules-during-iteration","title":"Safety rules during iteration","text":"<p>While iterating a query (or while systems are running), structural changes (spawn/despawn/add/remove) can throw.</p> <p>Use:</p> <ul> <li><code>world.cmd()</code> to defer changes</li> <li><code>world.flush()</code> (or <code>world.update()</code>) to apply them safely </li> </ul>"},{"location":"Reference/resources/","title":"Resources (Singletons / World Globals)","text":"<p>Resources are typed singleton values stored on the <code>World</code>, keyed by a <code>ComponentCtor&lt;T&gt;</code> (same \u201ckey shape\u201d as components). They are not attached to entities.</p> <p>They\u2019re ideal for global state like Time, Input, Asset caches, Config, RNG, Selection, etc.</p>"},{"location":"Reference/resources/#concepts","title":"Concepts","text":""},{"location":"Reference/resources/#what-is-a-resource","title":"What is a Resource?","text":"<p>A resource is a single instance of data stored globally in the ECS <code>World</code>.</p> <ul> <li>Components \u2192 many per world, attached to entities</li> <li>Resources \u2192 one per key, stored in the world</li> </ul>"},{"location":"Reference/resources/#key-type-componentctort","title":"Key type: <code>ComponentCtor&lt;T&gt;</code>","text":"<p>All resource APIs use:</p> <pre><code>ComponentCtor&lt;T&gt;\n</code></pre> <p>This usually means:</p> <ul> <li>a class constructor (e.g. <code>class TimeRes { ... }</code>)</li> <li>or a token function (unique function used as a key)</li> </ul> <p>Keys are compared by identity (reference equality), not by name.</p>"},{"location":"Reference/resources/#api-summary","title":"API summary","text":"<p>All methods live on <code>World</code> / <code>WorldApi</code>.</p> <pre><code>setResource&lt;T&gt;(key: ComponentCtor&lt;T&gt;, value: T): void\ngetResource&lt;T&gt;(key: ComponentCtor&lt;T&gt;): T | undefined\nrequireResource&lt;T&gt;(key: ComponentCtor&lt;T&gt;): T\nhasResource&lt;T&gt;(key: ComponentCtor&lt;T&gt;): boolean\nremoveResource&lt;T&gt;(key: ComponentCtor&lt;T&gt;): boolean\ninitResource&lt;T&gt;(key: ComponentCtor&lt;T&gt;, factory: () =&gt; T): T\n</code></pre> <p>Structural safety: resource operations are not structural changes (unlike spawn/despawn/add/remove). They do not require flushing and are safe to call during system execution.</p>"},{"location":"Reference/resources/#method-reference","title":"Method reference","text":""},{"location":"Reference/resources/#setresourcetkey-value-void","title":"<code>setResource&lt;T&gt;(key, value): void</code>","text":"<p>Stores (or replaces) the resource value for <code>key</code>.</p> <p>Behavior</p> <ul> <li>Overwrites any existing value.</li> <li>Does not flush and does not affect archetypes.</li> </ul> <p>Example</p> <pre><code>class ConfigRes { constructor(public difficulty: \"easy\" | \"hard\") {} }\n\nworld.setResource(ConfigRes, new ConfigRes(\"hard\"));\n</code></pre>"},{"location":"Reference/resources/#getresourcetkey-t-undefined","title":"<code>getResource&lt;T&gt;(key): T | undefined</code>","text":"<p>Returns the resource value if present, otherwise <code>undefined</code>.</p> <p>Use when</p> <ul> <li>the resource is optional (debug tools, plugins, editor-only state)</li> </ul> <p>Important note</p> <ul> <li>If you explicitly store <code>undefined</code> as the value, this also returns <code>undefined</code>.</li> <li> <p>Use <code>hasResource(key)</code> to distinguish:</p> </li> <li> <p>\u201cmissing\u201d</p> </li> <li>vs \u201cpresent but undefined\u201d</li> </ul> <p>Example</p> <pre><code>const debug = world.getResource(DebugRes);\nif (debug) debug.enabled = true;\n</code></pre>"},{"location":"Reference/resources/#requireresourcetkey-t","title":"<code>requireResource&lt;T&gt;(key): T</code>","text":"<p>Returns the resource value if present, otherwise throws.</p> <p>Use when</p> <ul> <li>the resource is required for correct operation (Time, Input, AssetCache, Config)</li> </ul> <p>Throws</p> <ul> <li><code>Error</code> if missing</li> </ul> <p>Example</p> <pre><code>const input = w.requireResource(InputStateRes);\nif (input.keysDown.has(\"KeyW\")) { /* ... */ }\n</code></pre>"},{"location":"Reference/resources/#hasresourcetkey-boolean","title":"<code>hasResource&lt;T&gt;(key): boolean</code>","text":"<p>Checks whether an entry exists for <code>key</code>.</p> <p>Use when</p> <ul> <li>you need to distinguish missing vs present-but-undefined</li> <li>you want conditional initialization</li> </ul> <p>Example</p> <pre><code>if (!world.hasResource(TimeRes)) {\n  world.setResource(TimeRes, new TimeRes());\n}\n</code></pre>"},{"location":"Reference/resources/#removeresourcetkey-boolean","title":"<code>removeResource&lt;T&gt;(key): boolean</code>","text":"<p>Removes the resource entry for <code>key</code>.</p> <p>Returns</p> <ul> <li><code>true</code> if the entry existed and was removed</li> <li><code>false</code> otherwise</li> </ul> <p>Example</p> <pre><code>world.removeResource(DebugRes);\n</code></pre>"},{"location":"Reference/resources/#initresourcetkey-factory-t","title":"<code>initResource&lt;T&gt;(key, factory): T</code>","text":"<p>Insert-once helper.</p> <p>Behavior</p> <ul> <li>If resource exists \u2192 returns existing value (factory is not called)</li> <li>If missing \u2192 calls <code>factory()</code>, stores, returns the new value</li> </ul> <p>Use when</p> <ul> <li>bootstrapping default resources without double-init</li> </ul> <p>Example</p> <pre><code>class TimeRes { dt = 0; elapsed = 0; }\n\nworld.initResource(TimeRes, () =&gt; new TimeRes());\n</code></pre>"},{"location":"Reference/resources/#usage-patterns","title":"Usage patterns","text":""},{"location":"Reference/resources/#pattern-bootstrap-required-resources-once","title":"Pattern: \u201cbootstrap required resources once\u201d","text":"<pre><code>class TimeRes { dt = 0; elapsed = 0; }\nclass InputStateRes { keysDown = new Set&lt;string&gt;(); }\n\nworld.initResource(TimeRes, () =&gt; new TimeRes());\nworld.initResource(InputStateRes, () =&gt; new InputStateRes());\n</code></pre>"},{"location":"Reference/resources/#pattern-systems-read-required-resources","title":"Pattern: \u201csystems read required resources\u201d","text":"<pre><code>function timeSystem(w: WorldApi, dt: number) {\n  const time = w.requireResource(TimeRes);\n  time.dt = dt;\n  time.elapsed += dt;\n}\n</code></pre>"},{"location":"Reference/resources/#pattern-asset-cache-resource","title":"Pattern: \u201casset cache resource\u201d","text":"<pre><code>class AssetCacheRes {\n  images = new Map&lt;string, HTMLImageElement&gt;();\n}\n\nworld.initResource(AssetCacheRes, () =&gt; new AssetCacheRes());\n</code></pre>"},{"location":"Reference/resources/#gotchas","title":"Gotchas","text":""},{"location":"Reference/resources/#1-keys-must-be-stable-and-unique","title":"1) Keys must be stable and unique","text":"<p>Because keys are identity-based:</p> <ul> <li>\u2705 <code>class TimeRes {}</code> used as key is stable</li> <li>\u2705 a top-level <code>const TOKEN = (() =&gt; {}) as ComponentCtor&lt;T&gt;</code> is stable</li> <li>\u274c creating a new token function inline each time won\u2019t match previous entries</li> </ul>"},{"location":"Reference/resources/#2-prefer-requireresource-in-gameplay-systems","title":"2) Prefer <code>requireResource()</code> in gameplay systems","text":"<p>It keeps systems clean and fails fast when initialization is missing.</p>"},{"location":"Reference/resources/#3-resources-are-not-entities","title":"3) Resources are not entities","text":"<p>Do not use resources for data that should exist per-entity (that\u2019s components).</p>"},{"location":"Reference/save-and-load/","title":"Save and Load (World Snapshot) Reference","text":"<p>This page documents the snapshot API on <code>World</code>.</p>"},{"location":"Reference/save-and-load/#methods","title":"Methods","text":""},{"location":"Reference/save-and-load/#registercomponentsnapshott-dkey-codec-this","title":"<code>registerComponentSnapshot&lt;T, D&gt;(key, codec): this</code>","text":"<p>Registers a component snapshot codec.</p> <ul> <li><code>key: ComponentCtor&lt;T&gt;</code> is the component token/class used in ECS storage.</li> <li><code>codec: SnapshotCodec&lt;T, D&gt;</code> defines:</li> <li><code>key: string</code> stable snapshot type key (for example <code>\"comp.position\"</code>)</li> <li><code>serialize(value: T): D</code></li> <li><code>deserialize(data: D): T</code></li> </ul> <p>Notes:</p> <ul> <li><code>codec.key</code> must be non-empty.</li> <li>Snapshot type keys must be unique per registry.</li> <li>Calling again with the same ctor replaces the previous codec.</li> </ul>"},{"location":"Reference/save-and-load/#unregistercomponentsnapshottkey-boolean","title":"<code>unregisterComponentSnapshot&lt;T&gt;(key): boolean</code>","text":"<p>Removes a registered component snapshot codec.</p> <p>Returns:</p> <ul> <li><code>true</code> if removed</li> <li><code>false</code> if none existed</li> </ul>"},{"location":"Reference/save-and-load/#registerresourcesnapshott-dkey-codec-this","title":"<code>registerResourceSnapshot&lt;T, D&gt;(key, codec): this</code>","text":"<p>Registers a resource snapshot codec.</p> <p>Same rules as component registration.</p>"},{"location":"Reference/save-and-load/#unregisterresourcesnapshottkey-boolean","title":"<code>unregisterResourceSnapshot&lt;T&gt;(key): boolean</code>","text":"<p>Removes a registered resource snapshot codec.</p>"},{"location":"Reference/save-and-load/#snapshot-worldsnapshot","title":"<code>snapshot(): WorldSnapshot</code>","text":"<p>Exports world state.</p> <p>Behavior:</p> <ul> <li>throws if called during iteration/structural lock</li> <li>flushes pending commands first</li> <li>serializes only registered components/resources</li> <li>returns deterministic ordering for entities/components/resources</li> </ul>"},{"location":"Reference/save-and-load/#restoresnapshot-worldsnapshot-void","title":"<code>restore(snapshot: WorldSnapshot): void</code>","text":"<p>Loads world state.</p> <p>Behavior:</p> <ul> <li>throws if called during iteration/structural lock</li> <li>validates snapshot format string</li> <li>clears pending commands</li> <li>clears event channel buffers</li> <li>clears current resources</li> <li>restores allocator + entities + registered data</li> </ul> <p><code>restore()</code> does not restore systems/schedules.</p>"},{"location":"Reference/save-and-load/#snapshotcodect-d","title":"<code>SnapshotCodec&lt;T, D&gt;</code>","text":"<pre><code>type SnapshotCodec&lt;T, D = unknown&gt; = {\n  key: string;\n  serialize(value: T): D;\n  deserialize(data: D): T;\n};\n</code></pre> <p>Guidelines:</p> <ul> <li>keep <code>key</code> stable across versions</li> <li>output JSON-safe data if you persist via <code>JSON.stringify</code></li> <li>avoid embedding runtime handles/functions in codec data</li> </ul>"},{"location":"Reference/save-and-load/#worldsnapshot-shape","title":"<code>WorldSnapshot</code> shape","text":"<pre><code>type WorldSnapshot = {\n  format: \"archetype-ecs/world-snapshot@1\";\n  allocator: {\n    nextId: number;\n    free: number[];\n    generations: Array&lt;readonly [id: number, gen: number]&gt;;\n  };\n  entities: Array&lt;{\n    id: number;\n    gen: number;\n    components: Array&lt;{ type: string; data: unknown }&gt;;\n  }&gt;;\n  resources: Array&lt;{ type: string; data: unknown }&gt;;\n};\n</code></pre>"},{"location":"Reference/save-and-load/#persisted-vs-non-persisted","title":"Persisted vs non-persisted","text":"<p>Persisted:</p> <ul> <li>alive entities</li> <li>registered components</li> <li>registered resources</li> <li>allocator state</li> </ul> <p>Not persisted:</p> <ul> <li>systems</li> <li>schedules</li> <li>events</li> <li>command queue</li> </ul>"},{"location":"Reference/save-and-load/#error-conditions-common","title":"Error conditions (common)","text":"<ul> <li>unsupported snapshot format</li> <li>duplicate snapshot type entries in payload</li> <li>missing codec for a component/resource type during restore</li> <li>invalid allocator/entity ids or generations</li> <li>entity id marked both alive and free</li> </ul>"},{"location":"Reference/save-and-load/#determinism-guarantees","title":"Determinism guarantees","text":"<p>For the same world state and codec outputs:</p> <ul> <li><code>entities</code> are ordered by entity id</li> <li>each entity <code>components</code> list is ordered by codec key</li> <li><code>resources</code> list is ordered by codec key</li> </ul>"},{"location":"Reference/schedule/","title":"Schedule","text":""},{"location":"Reference/schedule/#purpose","title":"Purpose","text":"<p><code>Schedule</code> is a multiphase runner.</p> <p>It groups system functions under named phases (e.g. <code>\"input\"</code>, <code>\"update\"</code>, <code>\"render\"</code>), then executes those phases in a chosen order. At phase boundaries, it can automatically:</p> <ul> <li>flush deferred structural commands (<code>world.flush()</code>, only if commands are pending)</li> <li>deliver events to the next phase (<code>world.swapEvents()</code>)</li> </ul> <p>This lets you build a deterministic pipeline (input \u2192 simulation \u2192 rendering \u2192 audio, etc.) without running into \"structural change during iteration\" problems.</p>"},{"location":"Reference/schedule/#construction","title":"Construction","text":"<pre><code>ts\nconst schedule = new Schedule();\n</code></pre> <p>A <code>Schedule</code> is independent from <code>World</code>, you pass the <code>world</code> at run time.</p>"},{"location":"Reference/schedule/#adding-systems-to-phases","title":"Adding systems to phases","text":""},{"location":"Reference/schedule/#addworld-worldapi-phase-string-fn-systemfn-after-before","title":"<code>add(world: WorldApi, phase: string, fn: SystemFn): { after, before }</code>","text":"<p>Registers <code>fn</code> under <code>phase</code> for the given <code>world</code>.</p> <ul> <li>You can register multiple systems under the same phase (they run in insertion order).</li> <li>Returns an object with <code>after()</code> and <code>before()</code> methods for chaining phase constraints.</li> </ul> <p>Example: <pre><code>ts\nschedule\n    .add(world, \"input\", inputSystem)\n    .add(world, \"update\", updateSystem)\n    .add(world, \"render\", renderSystem);\n</code></pre></p>"},{"location":"Reference/schedule/#phase-ordering-constraints","title":"Phase ordering constraints","text":"<p>Constraints are phase-level (not system-level): they affect the relative order of phases, not the order of systems within a phase.</p>"},{"location":"Reference/schedule/#afterotherphase-string-this","title":"<code>after(otherPhase: string): this</code>","text":"<p>Constrain the most recently added phase to run after <code>otherPhase</code>.</p> <pre><code>ts\nschedule.add(world, \"sim\", simSystem).after(\"input\"); // input -&gt; sim\n</code></pre> <p>You can chain multiple constraints: <pre><code>ts\nschedule.add(world, \"sim\", simSystem).after(\"beginFrame\").after(\"input\");\n</code></pre></p> <p><code>after()</code> must be called after <code>add(...)</code>. Calling it before any <code>add(...)</code> throws an error.</p>"},{"location":"Reference/schedule/#beforeotherphase-string-this","title":"<code>before(otherPhase: string): this</code>","text":"<p>Constrain the most recently added phase to run before <code>otherPhase</code>.</p> <pre><code>ts\nschedule.add(world, \"input\", inputSystem).before(\"sim\"); // input -&gt; sim\n</code></pre> <p><code>before()</code> must be called after <code>add(...)</code>. Calling it before any <code>add(...)</code> throws an error.</p>"},{"location":"Reference/schedule/#selecting-a-phase-order","title":"Selecting a phase order","text":"<p><code>Schedule.run()</code> chooses a phase order using the following precedence:</p> <ol> <li>If <code>run(..., phaseOrder)</code> is provided, it is used as-is.</li> <li>Else, if <code>setOrder([...])</code> was called, the stored order is used.</li> <li>Else, an order is computed from <code>.after()</code>/<code>.before()</code> constraints (stable topological sort).</li> </ol>"},{"location":"Reference/schedule/#setorderphases-string-this","title":"<code>setOrder(phases: string[]): this</code>","text":"<p>Set a default phase order used by <code>run(world, dt)</code> when no <code>phaseOrder</code> is passed.</p> <pre><code>ts\nschedule.setOrder([\"input\", \"sim\", \"render\"]);\n</code></pre>"},{"location":"Reference/schedule/#phase-boundary-behavior","title":"Phase boundary behavior","text":""},{"location":"Reference/schedule/#setboundarymodemode-auto-manual-this","title":"<code>setBoundaryMode(mode: \"auto\" | \"manual\"): this</code>","text":"<p>Controls what happens after each phase:</p> <ul> <li><code>\"auto\"</code> (default):<ul> <li>if <code>world.cmd().hasPending()</code> \u2192 <code>world.flush()</code></li> <li>always <code>world.swapEvents()</code></li> </ul> </li> <li><code>\"manual\"</code>:<ul> <li>do nothing automatically; the caller is responsible for <code>world.flush()</code> / <code>world.swapEvents()</code> <pre><code>ts\nschedule.setBoundaryMode(\"auto\"); // default\nschedule.setBoundaryMode(\"manual\"); // advanced usage\n</code></pre></li> </ul> </li> </ul>"},{"location":"Reference/schedule/#running-phases","title":"Running phases","text":""},{"location":"Reference/schedule/#runworld-worldapi-dt-number-phaseorder-string-void","title":"<code>run(world: WorldApi, dt: number, phaseOrder?: string[]): void</code>","text":"<p>Runs the schedule for a single tick:</p> <ul> <li>Executes phases in the chosen order.</li> <li>Executes all systems registered under each phase.</li> <li>Applies phase boundary behavior according to <code>setBoundaryMode()</code>.</li> </ul> <p>Example (explicit order): <pre><code>ts\nschedule.run(world, 1/60, [\"input\", \"sim\", \"render\"]);\n</code></pre></p> <p>Example (computed order from constraints): <pre><code>ts\nschedule\n    .add(world, \"input\", inputSystem)\n    .add(world, \"sim\", simSystem).after(\"input\")\n    .add(world, \"render\", renderSystem).after(\"sim\");\n\nschedule.run(world, 1 / 60);\n</code></pre></p>"},{"location":"Reference/schedule/#errors-and-lifecycle-notes","title":"Errors and lifecycle notes","text":"<ul> <li>System errors: If a system throws, <code>Schedule</code> rethrows a wrapped error with context:<ul> <li><code>\"[phase=&lt;phase&gt; system=&lt;name&gt;] &lt;message&gt;\"</code></li> </ul> </li> <li>Cyclic constraints: If constraints contain a cycle and no explicit order is provided, <code>run()</code> throws.</li> <li>No phase order: If no phase order can be determined (no explicit order, no stored order, and nothing scheduled), <code>run()</code> throws:<ul> <li><code>Schedule.run requires a phase order (pass it as an argument or call schedule.setOrder([...]))</code></li> </ul> </li> </ul>"},{"location":"Reference/schedule/#lifecycle-conflict-detection","title":"Lifecycle conflict detection","text":"<p><code>Schedule.run()</code> and <code>World.update()</code> are mutually exclusive on the same <code>World</code> instance:</p> <ul> <li>If you register systems via <code>world.addSystem()</code> and then call <code>schedule.run()</code>, an error is thrown.</li> <li>If you register systems via <code>schedule.add()</code> and then call <code>world.update()</code>, an error is thrown.</li> </ul> <p>This prevents confusing behavior from mixing two different system execution models in the same world.</p> <p>Choose ONE approach:</p> Approach Register systems with Run with Simple (single-phase) <code>world.addSystem(fn)</code> <code>world.update(dt)</code> Multi-phase <code>schedule.add(world, phase, fn)</code> <code>schedule.run(world, dt, phases)</code>"},{"location":"Reference/schedule/#relationship-to-worldupdatedt","title":"Relationship to <code>World.update(dt)</code>","text":"Feature <code>World.update(dt)</code> <code>Schedule.run(world, dt, phases)</code> System registration <code>world.addSystem(fn)</code> <code>schedule.add(world, phase, fn)</code> Phase support Single implicit phase Multiple named phases Phase ordering N/A Via <code>after()</code>/<code>before()</code> or explicit order Command flush Once at end After each phase (if pending) Event swap Once at end After each phase Best for Simple game loops, prototyping Complex pipelines, deterministic ordering"},{"location":"Reference/systems/","title":"Systems","text":""},{"location":"Reference/systems/#purpose","title":"Purpose","text":"<p>A system is a function executed by the ECS to update simulation state (usually by iterating queries and mutating component values). Systems are registered on the <code>World</code>, and executed during <code>world.update(dt)</code>. </p>"},{"location":"Reference/systems/#system-function-type","title":"System function type","text":""},{"location":"Reference/systems/#systemfn","title":"<code>SystemFn</code>","text":"<p>A system is a function with the signature:</p> <ul> <li><code>(world: WorldApi, dt: number) =&gt; void</code></li> </ul> <p>In practice, examples call <code>query()</code> and <code>cmd()</code> inside systems, which are available through <code>WorldApi</code>. </p>"},{"location":"Reference/systems/#registering-systems","title":"Registering systems","text":""},{"location":"Reference/systems/#worldaddsystemfn-this","title":"<code>world.addSystem(fn): this</code>","text":"<p>Adds a system to the world.</p> <ul> <li>Systems run in the order they were added (as described by \u201cruns systems in order\u201d). </li> </ul> <p>Example: </p> <pre><code>world.addSystem((w: any, dt: number) =&gt; {\n    for (const { e, c1: pos, c2: vel } of w.query(Position, Velocity)) {\n        pos.x += vel.x * dt;\n        pos.y += vel.y * dt;\n\n        if (pos.x &gt; 10) w.cmd().despawn(e);\n    }\n});\n</code></pre>"},{"location":"Reference/systems/#running-systems-frame-execution","title":"Running systems (frame execution)","text":""},{"location":"Reference/systems/#worldupdatedt-void","title":"<code>world.update(dt): void</code>","text":"<p>Runs one ECS frame:</p> <ol> <li>Runs all registered systems (in order)</li> <li>Flushes queued commands at the end </li> </ol> <p>The reference summary explicitly lists:</p> <ul> <li><code>addSystem(fn): this</code></li> <li><code>update(dt): void</code> (runs systems in order, then flushes) </li> </ul>"},{"location":"Reference/systems/#structural-changes-inside-systems","title":"Structural changes inside systems","text":"<p>While systems are running (and while iterating queries), doing structural changes directly can throw. The recommended pattern is:</p> <ul> <li>enqueue structural changes with <code>world.cmd()</code></li> <li>apply them with <code>world.flush()</code> (or let <code>update()</code> do it at the end) </li> </ul>"},{"location":"Reference/systems/#systems-in-phases-schedule","title":"Systems in phases (Schedule)","text":"<p>If you need explicit ordering across groups of systems, use <code>Schedule</code>:</p> <ul> <li><code>sched.add(phase, systemFn)</code></li> <li><code>sched.run(world, dt, phases)</code> runs phases in order and calls <code>world.flush()</code> after each phase </li> </ul> <p>This provides deterministic \u201cphase barriers\u201d where deferred commands are applied. </p>"},{"location":"Reference/world/","title":"World","text":""},{"location":"Reference/world/#purpose","title":"Purpose","text":"<p><code>World</code> is the central authority of the ECS. It owns and coordinates:</p> <ul> <li>entity lifecycle</li> <li>archetypes and component storage</li> <li>queries</li> <li>deferred structural commands</li> <li>system execution</li> </ul> <p>There is exactly one <code>World</code> instance per ECS context.</p>"},{"location":"Reference/world/#construction","title":"Construction","text":"<pre><code>const world = new World();\n</code></pre>"},{"location":"Reference/world/#side-effects","title":"Side effects","text":"<ul> <li>Initializes an empty entity pool</li> <li>Initializes archetype storage</li> <li>Initializes command buffer</li> <li>Initializes system list</li> </ul>"},{"location":"Reference/world/#entity-lifecycle-api","title":"Entity Lifecycle API","text":""},{"location":"Reference/world/#spawn-entity","title":"<code>spawn(): Entity</code>","text":"<p>Creates a new entity immediately.</p> <ul> <li>Allocates a new entity id</li> <li>Marks entity as alive</li> <li>Places entity in the empty archetype</li> </ul> <pre><code>const e = world.spawn();\n</code></pre>"},{"location":"Reference/world/#spawnmanyitems-componentctorbundleitem-entity","title":"<code>spawnMany(...items: ComponentCtorBundleItem[]): Entity</code>","text":"<p>Creates a new entity along with its initial components immediately.</p> <ul> <li><code>...items: ComponentCtorBundleItem[]</code> is the list of components to add to the newly created entity.</li> <li>Internally, it iterates over the items and calls <code>add</code> for each component.</li> </ul>"},{"location":"Reference/world/#despawne-entity-void","title":"<code>despawn(e: Entity): void</code>","text":"<p>Immediately removes an entity.</p> <ul> <li>Invalidates the entity handle (<code>gen</code> mismatch)</li> <li>Removes the entity from its archetype</li> <li>Frees the slot for reuse</li> </ul> <p>Throws if:</p> <ul> <li>entity is stale or not alive</li> </ul>"},{"location":"Reference/world/#despawnmanyentities-entity-void","title":"<code>despawnMany(entities: Entity[]): void</code>","text":"<p>Immediately removes multiple entities.</p> <ul> <li><code>entities: Entity[]</code> is the list of entities to despawn.</li> <li>Internally, it iterates over the array and calls <code>despawn(e)</code> for each entity.</li> </ul>"},{"location":"Reference/world/#isalivee-entity-boolean","title":"<code>isAlive(e: Entity): boolean</code>","text":"<p>Checks whether an entity handle is still valid.</p> <pre><code>if (world.isAlive(e)) { ... }\n</code></pre>"},{"location":"Reference/world/#component-api","title":"Component API","text":"<p>All component types are identified by constructor identity.</p>"},{"location":"Reference/world/#haste-entity-ctor-componentctort-boolean","title":"<code>has&lt;T&gt;(e: Entity, ctor: ComponentCtor&lt;T&gt;): boolean</code>","text":"<p>Checks if an entity has a component.</p>"},{"location":"Reference/world/#gette-entity-ctor-componentctort-t-undefined","title":"<code>get&lt;T&gt;(e: Entity, ctor: ComponentCtor&lt;T&gt;): T | undefined</code>","text":"<p>Returns the component value or <code>undefined</code>.</p> <ul> <li>Does not throw if missing</li> <li>Returns <code>undefined</code> for stale entities</li> </ul>"},{"location":"Reference/world/#addte-entity-ctor-componentctort-value-t-void","title":"<code>add&lt;T&gt;(e: Entity, ctor: ComponentCtor&lt;T&gt;, value: T): void</code>","text":"<p>Adds a component to an entity.</p> <ul> <li>Structural change</li> <li>Moves the entity to a different archetype</li> </ul> <p>Throws if:</p> <ul> <li>entity is stale</li> <li>component already exists</li> <li>structural changes are forbidden (see iteration rules)</li> </ul>"},{"location":"Reference/world/#addmanye-entity-items-componentctorbundleitem-void","title":"<code>addMany(e: Entity, ...items: ComponentCtorBundleItem[]): void</code>","text":"<p>Adding multiple components to an existing entity.</p> <ul> <li><code>e: Entity</code> is the target entity.</li> <li><code>...items: ComponentCtorBundleItem[]</code> is the list of components to add.</li> <li>Internally, it loops through the items and calls <code>add</code> for each component.</li> </ul>"},{"location":"Reference/world/#removete-entity-ctor-componentctort-void","title":"<code>remove&lt;T&gt;(e: Entity, ctor: ComponentCtor&lt;T&gt;): void</code>","text":"<p>Removes a component.</p> <ul> <li>Structural change</li> <li>Moves the entity to a different archetype</li> </ul> <p>Throws if:</p> <ul> <li>entity is stale</li> <li>component does not exist</li> <li>structural changes are forbidden</li> </ul>"},{"location":"Reference/world/#removemanye-entity-ctors-componentctorany-void","title":"<code>removeMany(e: Entity, ...ctors: ComponentCtor&lt;any&gt;[]): void</code>","text":"<p>Removes multiple component types from an entity.</p> <ul> <li><code>e: Entity</code> is the target entity.</li> <li><code>...ctors: ComponentCtor&lt;any&gt;[]</code> is the list of component constructors (types) to remove.</li> <li>Internally, it loops through the ctors and calls <code>remove</code> for each one.</li> </ul>"},{"location":"Reference/world/#sette-entity-ctor-componentctort-value-t-void","title":"<code>set&lt;T&gt;(e: Entity, ctor: ComponentCtor&lt;T&gt;, value: T): void</code>","text":"<p>Updates an existing component value.</p> <ul> <li>Non-structural</li> <li>Does not change archetypes</li> </ul> <p>Throws if:</p> <ul> <li>entity is stale</li> <li>component does not exist</li> </ul>"},{"location":"Reference/world/#query-api","title":"Query API","text":""},{"location":"Reference/world/#queryctors-iterablequeryrow","title":"<code>query(...ctors): Iterable&lt;QueryRow&gt;</code>","text":"<p>Iterates entities that contain all requested components.</p> <pre><code>for (const { e, c1, c2 } of world.query(A, B)) {\n    // e  -&gt; Entity\n    // c1 -&gt; A\n    // c2 -&gt; B\n}\n</code></pre>"},{"location":"Reference/world/#properties","title":"Properties","text":"<ul> <li>Iterates archetypes, not entities</li> <li>Components are returned as <code>c1</code>, <code>c2</code>, \u2026 in argument order</li> <li>Query iteration locks structural changes</li> </ul>"},{"location":"Reference/world/#structural-change-rules","title":"Structural Change Rules","text":"<p>While iterating a query or running systems:</p> <ul> <li>\u274c <code>spawn</code>, <code>despawn</code>, <code>add</code>, <code>remove</code> are forbidden</li> <li>\u2714\ufe0f <code>get</code>, <code>set</code>, <code>has</code> are allowed</li> </ul> <p>Violations throw a runtime error.</p>"},{"location":"Reference/world/#command-buffer-api","title":"Command Buffer API","text":""},{"location":"Reference/world/#cmd-commands","title":"<code>cmd(): Commands</code>","text":"<p>Returns a command buffer for deferred structural changes.</p> <pre><code>world.cmd().despawn(e);\n</code></pre> <p>Commands are queued, not applied immediately.</p>"},{"location":"Reference/world/#flush-void","title":"<code>flush(): void</code>","text":"<p>Applies all queued commands.</p> <ul> <li>Safe to call after queries</li> <li>Automatically called by <code>update()</code> and <code>Schedule</code></li> </ul>"},{"location":"Reference/world/#snapshot-restore-api","title":"Snapshot / Restore API","text":""},{"location":"Reference/world/#registercomponentsnapshott-dkey-componentctort-codec-snapshotcodect-d-this","title":"<code>registerComponentSnapshot&lt;T, D&gt;(key: ComponentCtor&lt;T&gt;, codec: SnapshotCodec&lt;T, D&gt;): this</code>","text":"<p>Registers a component serializer/deserializer for snapshots.</p>"},{"location":"Reference/world/#unregistercomponentsnapshottkey-componentctort-boolean","title":"<code>unregisterComponentSnapshot&lt;T&gt;(key: ComponentCtor&lt;T&gt;): boolean</code>","text":"<p>Removes a component snapshot registration.</p>"},{"location":"Reference/world/#registerresourcesnapshott-dkey-componentctort-codec-snapshotcodect-d-this","title":"<code>registerResourceSnapshot&lt;T, D&gt;(key: ComponentCtor&lt;T&gt;, codec: SnapshotCodec&lt;T, D&gt;): this</code>","text":"<p>Registers a resource serializer/deserializer for snapshots.</p>"},{"location":"Reference/world/#unregisterresourcesnapshottkey-componentctort-boolean","title":"<code>unregisterResourceSnapshot&lt;T&gt;(key: ComponentCtor&lt;T&gt;): boolean</code>","text":"<p>Removes a resource snapshot registration.</p>"},{"location":"Reference/world/#snapshot-worldsnapshot","title":"<code>snapshot(): WorldSnapshot</code>","text":"<p>Exports world data state (entities + registered components/resources + allocator).</p>"},{"location":"Reference/world/#restoresnapshot-worldsnapshot-void","title":"<code>restore(snapshot: WorldSnapshot): void</code>","text":"<p>Loads snapshot data into the world.</p> <p>Runtime behavior (systems/schedule/events/queued commands) is not persisted.</p>"},{"location":"Reference/world/#system-api","title":"System API","text":""},{"location":"Reference/world/#addsystemfn-systemfn-this","title":"<code>addSystem(fn: SystemFn): this</code>","text":"<p>Registers a system.</p> <pre><code>world.addSystem((w, dt) =&gt; { ... });\n</code></pre> <p>Systems are executed in insertion order.</p>"},{"location":"Reference/world/#updatedt-number-void","title":"<code>update(dt: number): void</code>","text":"<p>Runs one ECS frame.</p> <p>Execution order:</p> <ol> <li>Run all systems</li> <li>Flush deferred commands</li> </ol> <pre><code>world.update(1 / 60);\n</code></pre>"},{"location":"Reference/world/#events-api","title":"Events API","text":""},{"location":"Reference/world/#emittkey-componentctort-ev-t-void","title":"<code>emit&lt;T&gt;(key: ComponentCtor&lt;T&gt;, ev: T): void</code>","text":"<p>Emits an event of type <code>T</code> into the current phase write buffer.</p>"},{"location":"Reference/world/#eventstkey-componentctort-eventchannelt","title":"<code>events&lt;T&gt;(key: ComponentCtor&lt;T&gt;): EventChannel&lt;T&gt;</code>","text":"<p>Returns the event channel for <code>key</code>, creating it if missing.</p>"},{"location":"Reference/world/#draineventstkey-componentctort-fn-ev-t-void-void","title":"<code>drainEvents&lt;T&gt;(key: ComponentCtor&lt;T&gt;, fn: (ev: T) =&gt; void): void</code>","text":"<p>Drains readable events for the given type.</p> <p>Behavior</p> <ul> <li>If the channel doesn\u2019t exist yet, it\u2019s a no-op (does not allocate/create)</li> </ul>"},{"location":"Reference/world/#cleareventstkey-componentctort-void","title":"<code>clearEvents&lt;T&gt;(key?: ComponentCtor&lt;T&gt;): void</code>","text":"<p>Clears readable events.</p> <ul> <li>If <code>key</code> is provided: clears that event type\u2019s read buffer</li> <li>If omitted: clears the read buffers of all event types</li> </ul>"},{"location":"Reference/world/#swapevents-void-internal-schedule-boundary","title":"<code>swapEvents(): void</code> (internal / schedule boundary)","text":"<p>Swaps all event channels\u2019 buffers. Called by <code>Schedule</code> at phase boundaries.</p> <p>Required schedule behavior At each phase boundary:</p> <pre><code>world.flush();\nworld.swapEvents();\n</code></pre>"},{"location":"Reference/world/#internal-guarantees","title":"Internal Guarantees","text":"<ul> <li>Archetypes use Structure of Arrays (SoA)</li> <li>Entity handles are generation-safe</li> <li>Component lookups are O(1) per archetype row</li> <li>Queries are archetype-filtered, not entity-scanned</li> </ul>"},{"location":"Reference/world/#error-conditions-summary","title":"Error Conditions (Summary)","text":"Operation Error Condition add / remove during query iteration add component already exists remove component missing set component missing any stale entity"},{"location":"Reference/world/#design-constraints","title":"Design Constraints","text":"<ul> <li>Single-threaded</li> <li>No automatic conflict detection</li> <li>No parallel systems</li> <li>No borrowing model</li> </ul> <p>These are intentional for simplicity and predictability.</p>"},{"location":"Tutorials/Debugging-Your-First-ECS-Application/","title":"Debugging Your First ECS Application","text":"<p>In this tutorial, you'll learn how to use the built-in debugging tools to understand and optimize your ECS application.</p>"},{"location":"Tutorials/Debugging-Your-First-ECS-Application/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic familiarity with the ECS library</li> <li>A working browser-based project</li> <li>About 15 minutes</li> </ul>"},{"location":"Tutorials/Debugging-Your-First-ECS-Application/#what-youll-build","title":"What You'll Build","text":"<p>A simple simulation with intentional performance issues that you'll identify and fix using the debugging tools.</p>"},{"location":"Tutorials/Debugging-Your-First-ECS-Application/#step-1-create-a-world-with-stats-overlay","title":"Step 1: Create a World with Stats Overlay","text":"<p>Create a new file <code>debug-tutorial.ts</code>:</p> <pre><code>import { World } from \"archetype-ecs-lib\";\n\n// Create world - overlay appears automatically\nconst world = new World({\n    statsOverlayOptions: {\n        width: 400,\n        height: 100\n    }\n});\nworld.setDebugging(true);\n\nconsole.log(\"World created! Look for the stats overlay in the top-left corner.\");\n</code></pre> <p>Run your application. You should see the ECS Stats overlay appear.</p> <p>Checkpoint: The overlay should show: - Frame 0 - Archetypes: 1 - Alive entities: 0</p>"},{"location":"Tutorials/Debugging-Your-First-ECS-Application/#step-2-add-some-entities","title":"Step 2: Add Some Entities","text":"<p>Let's spawn some entities and watch the stats update:</p> <pre><code>// Components\nclass Position { constructor(public x = 0, public y = 0) {} }\nclass Velocity { constructor(public vx = 0, public vy = 0) {} }\n\n// Spawn 100 moving entities\nfor (let i = 0; i &lt; 100; i++) {\n    const e = world.spawn();\n    world.add(e, Position, new Position(Math.random() * 800, Math.random() * 600));\n    world.add(e, Velocity, new Velocity(Math.random() * 2 - 1, Math.random() * 2 - 1));\n}\n\nconsole.log(\"Spawned 100 entities\");\n</code></pre> <p>Checkpoint: The overlay should now show: - Archetypes: 2 (empty + Position+Velocity) - Alive entities: 100 - Rows: 100</p>"},{"location":"Tutorials/Debugging-Your-First-ECS-Application/#step-3-add-a-movement-system","title":"Step 3: Add a Movement System","text":"<pre><code>function movementSystem(world: World, dt: number) {\n    for (const { e, c1: pos, c2: vel } of world.query(Position, Velocity)) {\n        pos.x += vel.vx * dt * 60;\n        pos.y += vel.vy * dt * 60;\n    }\n}\n\nworld.addSystem(movementSystem);\n</code></pre>"},{"location":"Tutorials/Debugging-Your-First-ECS-Application/#step-4-create-the-game-loop","title":"Step 4: Create the Game Loop","text":"<pre><code>let lastTime = performance.now();\n\nfunction gameLoop() {\n    const now = performance.now();\n    const dt = (now - lastTime) / 1000;\n    lastTime = now;\n\n    world.update(dt);\n\n    requestAnimationFrame(gameLoop);\n}\n\ngameLoop();\n</code></pre> <p>Checkpoint: - Watch the frame counter increment - The graph should show blue bars (fast frames) - <code>frame=</code> should be very low (&lt; 1ms)</p>"},{"location":"Tutorials/Debugging-Your-First-ECS-Application/#step-5-introduce-a-performance-problem","title":"Step 5: Introduce a Performance Problem","text":"<p>Let's add a \"bad\" system that creates performance issues:</p> <pre><code>function expensiveSystem(world: World, dt: number) {\n    // Simulate expensive computation\n    for (const { e, c1: pos } of world.query(Position)) {\n        // Intentionally slow: nested loop\n        let sum = 0;\n        for (let i = 0; i &lt; 10000; i++) {\n            sum += Math.sin(pos.x + i) * Math.cos(pos.y + i);\n        }\n        (pos as any)._temp = sum; // Store result\n    }\n}\n\nworld.addSystem(expensiveSystem);\n</code></pre> <p>Checkpoint: - Watch <code>frame=</code> time increase dramatically - Red bars should appear in the graph - Click to see phase timings in the console</p>"},{"location":"Tutorials/Debugging-Your-First-ECS-Application/#step-6-identify-the-slow-system","title":"Step 6: Identify the Slow System","text":"<p>Open your browser's developer console and click the button on the overlay to enable debug logging.</p> <p>You'll see the output something like:</p> <pre><code>Phases: update=45.23ms\n</code></pre> <p>But we need per-system timing! The overlay shows this when using named functions:</p> <p>Look at the overlay carefully. With profiling enabled, you'll see which system takes the most time.</p>"},{"location":"Tutorials/Debugging-Your-First-ECS-Application/#step-7-fix-the-performance-issue","title":"Step 7: Fix the Performance Issue","text":"<p>Now that we've identified <code>expensiveSystem</code> as the problem, let's optimize it:</p> <pre><code>// Option 1: Process fewer entities per frame\nlet processedThisFrame = 0;\nfunction optimizedExpensiveSystem(world: World, dt: number) {\n    processedThisFrame = 0;\n    for (const { e, c1: pos } of world.query(Position)) {\n        if (processedThisFrame++ &gt; 10) break; // Only process 10 per frame\n\n        let sum = 0;\n        for (let i = 0; i &lt; 10000; i++) {\n            sum += Math.sin(pos.x + i) * Math.cos(pos.y + i);\n        }\n        (pos as any)._temp = sum;\n    }\n}\n\n// Replace the bad system (in real code, you'd remove and re-add)\n</code></pre>"},{"location":"Tutorials/Debugging-Your-First-ECS-Application/#step-8-verify-the-fix","title":"Step 8: Verify the Fix","text":"<p>After applying the optimization:</p> <p>Checkpoint: - <code>frame=</code> time should drop significantly - Graph should return to mostly blue bars - Console logging should show lower phase times</p>"},{"location":"Tutorials/Debugging-Your-First-ECS-Application/#step-9-explore-archetype-fragmentation","title":"Step 9: Explore Archetype Fragmentation","text":"<p>Let's intentionally cause archetype fragmentation:</p> <pre><code>class TempMarker {}\n\nfunction fragmentingSystem(world: World, dt: number) {\n    for (const { e } of world.query(Position)) {\n        // Bad pattern: constantly adding/removing components\n        if (Math.random() &gt; 0.5) {\n            if (!world.has(e, TempMarker)) {\n                world.add(e, TempMarker, new TempMarker());\n            }\n        } else {\n            if (world.has(e, TempMarker)) {\n                world.remove(e, TempMarker);\n            }\n        }\n    }\n}\n\nworld.addSystem(fragmentingSystem);\n</code></pre> <p>Checkpoint: - Watch the \"Archetypes\" counter grow - This indicates archetype fragmentation</p>"},{"location":"Tutorials/Debugging-Your-First-ECS-Application/#step-10-clean-up","title":"Step 10: Clean Up","text":"<p>Remove the debugging artifacts when going to production:</p> <pre><code>// Disable profiling for release builds\nif (process.env.NODE_ENV === \"production\") {\n    world.setProfilingEnabled(false);\n    world.destroyOverlay();\n}\n</code></pre>"},{"location":"Tutorials/Debugging-Your-First-ECS-Application/#summary","title":"Summary","text":"<p>In this tutorial, you learned how to:</p> <ol> <li>Create a World with the stats overlay</li> <li>Read entity and archetype counts</li> <li>Identify slow systems using frame timing</li> <li>Enable console debug logging</li> <li>Recognize archetype fragmentation</li> <li>Disable debugging tools for production</li> </ol>"},{"location":"Tutorials/Debugging-Your-First-ECS-Application/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Understanding ECS Debugging &amp; Profiling to understand what the metrics mean</li> <li>Check the Debugging &amp; Profiling Reference for all available options</li> <li>Explore the How to Debug Your ECS Application for optimization techniques</li> </ul>"},{"location":"Tutorials/Tutorial-1%E2%80%94Your-first-ECS-World/","title":"Tutorial 1 \u2014 Your first ECS World","text":"<p>Outcome: you\u2019ll run a tiny simulation loop where entities with <code>Position</code> + <code>Velocity</code> move over time, using <code>World</code>, <code>spawn</code>, <code>add</code>, <code>query</code>, <code>addSystem</code>, and <code>update(dt)</code>. </p>"},{"location":"Tutorials/Tutorial-1%E2%80%94Your-first-ECS-World/#1-what-is-an-ecs-one-sentence","title":"1) What is an ECS? (one sentence)","text":"<p>ECS is a way to build simulations where entities are IDs, components are data, and systems are functions that iterate entities with specific components. </p>"},{"location":"Tutorials/Tutorial-1%E2%80%94Your-first-ECS-World/#2-create-a-tiny-project","title":"2) Create a tiny project","text":"<pre><code>mkdir ecs-tutorial-1\ncd ecs-tutorial-1\nnpm init -y\nnpm i archetype-ecs-lib\nnpm i -D typescript tsx\n</code></pre> <p>Install is <code>npm i archetype-ecs-lib</code>. </p>"},{"location":"Tutorials/Tutorial-1%E2%80%94Your-first-ECS-World/#3-create-tutorial1ts","title":"3) Create <code>tutorial1.ts</code>","text":"<p>Create a file named <code>tutorial1.ts</code> with this code:</p> <pre><code>import { World, WorldApi } from \"archetype-ecs-lib\";\n\n// 1) Components = data (any class can be a component type)\nclass Position { constructor(public x = 0, public y = 0) {} }\nclass Velocity { constructor(public x = 0, public y = 0) {} }\n\n// 2) Create a World (owns entities, components, systems)\nconst world = new World();\n\n// 3) Spawn an entity and add components\nconst e = world.spawnMany(\n  new Position(0, 0, 0),\n  new Velocity(2, 0)// 2 units/sec along x\n)\n\n// 4) Add a system (runs each update)\nworld.addSystem((w, dt) =&gt; {\n  for (const { e, c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x * dt;\n    pos.y += vel.y * dt;\n  }\n});\n\n// 5) Run a small simulation loop (60 frames)\nconst dt = 1 / 60;\n\nfor (let frame = 1; frame &lt;= 60; frame++) {\n  world.update(dt);\n\n  // Read back Position and print it\n  const pos = world.get(e, Position)!;\n  if (frame % 10 === 0) {\n    console.log(`frame ${frame}: x=${pos.x.toFixed(2)} y=${pos.y.toFixed(2)}`);\n  }\n}\n</code></pre> <p>This uses the documented API:</p> <ul> <li><code>spawn()</code>, <code>add(e, Ctor, value)</code></li> <li><code>addSystem(fn)</code></li> <li><code>query(Position, Velocity)</code> yielding <code>{ e, c1, c2 }</code></li> <li><code>update(dt)</code> to run systems each tick</li> </ul>"},{"location":"Tutorials/Tutorial-1%E2%80%94Your-first-ECS-World/#4-run-it","title":"4) Run it","text":"<pre><code>npx tsx tutorial1.ts\n</code></pre> <p>You should see something like:</p> <ul> <li><code>frame 10: x=0.33 ...</code></li> <li><code>frame 60: x=2.00 ...</code></li> </ul> <p>(Your exact decimals may differ slightly depending on rounding.)</p>"},{"location":"Tutorials/Tutorial-1%E2%80%94Your-first-ECS-World/#5-youve-built-the-core-loop","title":"5) You\u2019ve built the core loop","text":"<p>You now have:</p> <ul> <li>a <code>World</code></li> <li>entities created with <code>spawn()</code></li> <li>components added with <code>add()</code></li> <li>a system iterating <code>query(...)</code></li> <li>a running simulation driven by <code>update(dt)</code> </li> </ul>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/","title":"Tutorial 2 \u2014 Components &amp; archetypes","text":"<p>Outcome: you\u2019ll see how component sets automatically form archetypes (tables), and how entities \u201cmove\u201d between them when you <code>add()</code> / <code>remove()</code> components\u2014without digging into internals. Archetypes store data in SoA (one column per component type). </p>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#1-define-a-few-component-types","title":"1) Define a few component types","text":"<p>Create <code>tutorial2.ts</code>:</p> <pre><code>import { World } from \"archetype-ecs-lib\";\n\n// Components are just data classes\nclass Position { constructor(public x = 0, public y = 0) {} }\nclass Velocity { constructor(public x = 0, public y = 0) {} }\nclass Health   { constructor(public hp = 100) {} }\n</code></pre> <p>The ECS uses component constructors as the \u201ctype key\u201d, and archetypes store entities in SoA tables. </p>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#2-create-a-world-and-spawn-entities-with-different-component-sets","title":"2) Create a World and spawn entities with different component sets","text":"<pre><code>const world = new World();\n\n// e1 has: Position\nconst e1 = world.spawn();\nworld.add(e1, Position, new Position(1, 1));\n\n// e2 has: Position + Velocity\nconst e2 = world.spawn();\nworld.add(e2, Position, new Position(0, 0));\nworld.add(e2, Velocity, new Velocity(1, 0));\n\n// e3 has: Health\nconst e3 = world.spawn();\nworld.add(e3, Health, new Health(50));\n</code></pre>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#3-add-a-tiny-helper-to-see-matches","title":"3) Add a tiny helper to \u201csee\u201d matches","text":"<p>We can\u2019t (and don\u2019t need to) access archetype tables directly. Instead, we observe which queries match, before and after structural changes.</p> <pre><code>function ids(iter: Iterable&lt;{ e: { id: number } }&gt;): number[] {\n  const out: number[] = [];\n  for (const row of iter) out.push(row.e.id);\n  return out.sort((a, b) =&gt; a - b);\n}\n\nfunction dump(label: string) {\n  console.log(`\\n=== ${label} ===`);\n  console.log(\"Position:\", ids(world.query(Position)));\n  console.log(\"Velocity:\", ids(world.query(Velocity)));\n  console.log(\"Health:  \", ids(world.query(Health)));\n  console.log(\"Pos+Vel: \", ids(world.query(Position, Velocity)));\n  console.log(\"Pos+HP:  \", ids(world.query(Position, Health)));\n}\n</code></pre> <p>The query API yields <code>{ e, c1, c2, ... }</code> rows in the order you request components. </p>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#4-observe-the-automatic-archetypes-effect","title":"4) Observe the \u201cautomatic archetypes\u201d effect","text":"<p>Add this and run once:</p> <pre><code>dump(\"initial\");\n</code></pre> <p>You\u2019ll see (by IDs) that:</p> <ul> <li><code>e1</code> matches <code>Position</code> only</li> <li><code>e2</code> matches both <code>Position</code> and <code>Pos+Vel</code></li> <li><code>e3</code> matches <code>Health</code> only</li> </ul> <p>What this demonstrates: entities with the same component set are stored together (same archetype). Archetypes are created implicitly as you introduce new component combinations. </p>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#5-make-an-entity-move-between-archetypes-add","title":"5) Make an entity \u201cmove\u201d between archetypes (add)","text":"<p>Now add a component to <code>e1</code>:</p> <pre><code>world.add(e1, Velocity, new Velocity(0, 2));\ndump(\"after: add Velocity to e1\");\n</code></pre> <p>You should see:</p> <ul> <li><code>e1</code> now appears in <code>Velocity</code></li> <li>and also in <code>Pos+Vel</code></li> </ul> <p>Why: <code>add()</code> is a structural change that can move an entity into a different archetype table (because its component set changed). </p>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#6-make-an-entity-move-between-archetypes-remove","title":"6) Make an entity \u201cmove\u201d between archetypes (remove)","text":"<p>Now remove <code>Position</code> from <code>e2</code>:</p> <pre><code>world.remove(e2, Position);\ndump(\"after: remove Position from e2\");\n</code></pre> <p>You should see:</p> <ul> <li><code>e2</code> disappears from <code>Position</code> and <code>Pos+Vel</code></li> <li><code>e2</code> still appears in <code>Velocity</code></li> </ul> <p>Again: <code>remove()</code> is structural and can move the entity to a new archetype. </p>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#7-run-it","title":"7) Run it","text":"<pre><code>npx tsx tutorial2.ts\n</code></pre>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#what-you-just-learned-by-doing","title":"What you just learned (by doing)","text":"<ul> <li>Components are plain data types (classes). </li> <li>Archetypes (tables) are created automatically for each distinct component set, stored in SoA layout. </li> <li>When you <code>add()</code>/<code>remove()</code> components, entities \u201cmove\u201d because their component set changes (structural change). </li> </ul> <p>Note for later tutorials: structural changes can be unsafe while iterating; that\u2019s why <code>cmd()</code> + <code>flush()</code> exist. </p>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/","title":"Tutorial 3 \u2014 Deferred structural changes","text":"<p>Outcome: you\u2019ll learn the one rule that prevents most ECS bugs: don\u2019t change entity structure while iterating. You\u2019ll reproduce the problem safely, then fix it using Commands and flush points (via <code>Schedule</code>). The library explicitly supports this workflow: defer structural operations with <code>world.cmd()</code> and apply them with <code>world.flush()</code> / <code>Schedule</code> phase boundaries. </p>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#1-create-tutorial4ts","title":"1) Create <code>tutorial4.ts</code>","text":"<pre><code>import { World, WorldApi, Schedule } from \"archetype-ecs-lib\";\n</code></pre>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#2-define-simple-components","title":"2) Define simple components","text":"<pre><code>class Position { constructor(public x = 0) {} }\nclass Velocity { constructor(public x = 0) {} }\n</code></pre>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#3-setup-spawn-a-few-movers","title":"3) Setup: spawn a few movers","text":"<pre><code>const world = new World();\n\nfunction spawnMover(x: number, vx: number) {\n  const e = world.spawn();\n  world.add(e, Position, new Position(x));\n  world.add(e, Velocity, new Velocity(vx));\n  return e;\n}\n\nspawnMover(0,  2);\nspawnMover(5, -3);\nspawnMover(9,  1);\n</code></pre> <p>This is standard structural usage: <code>spawn()</code> + <code>add()</code>. </p>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#4-the-unsafe-thing-dont-do-this","title":"4) The unsafe thing (don\u2019t do this)","text":"<p>Add this function:</p> <pre><code>const unsafeDespawnInsideQuery: SystemFn = (w: WorldApi) =&gt; {\n  for (const { e, c1: pos } of w.query(Position)) {\n    if (pos.x &gt; 8) {\n      // \u274c Structural change during iteration (may throw)\n      w.despawn(e);\n    }\n  }\n}\n</code></pre> <p>Now call it once (inside a try/catch so the tutorial keeps going):</p> <pre><code>try {\n  unsafeDespawnInsideQuery(world);\n  console.log(\"unsafe: no error (but still not safe)\");\n} catch (err: any) {\n  console.log(\"unsafe: error as expected -&gt;\", String(err.message ?? err));\n}\n</code></pre> <p>The lib will warn that structural changes during query iteration can throw and instructs to use <code>cmd()</code> + <code>flush()</code> instead. </p>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#5-the-safe-fix-use-commands","title":"5) The safe fix: use Commands","text":"<p>Replace the unsafe function with a safe one:</p> <pre><code>const safeDespawnInsideQuery: SystemFn = (w: WorldApi) =&gt; {\n  for (const { e, c1: pos } of w.query(RenderContextComponent)) {\n    if (pos.x &gt; 8) {\n      // \u2705 Defer structural change\n      w.cmd().despawn(e);\n    }\n  }\n}\n</code></pre> <p>Commands let you queue:</p> <ul> <li><code>spawn</code>, <code>despawn</code>, <code>add</code>, <code>remove</code> </li> </ul>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#6-apply-commands-at-a-flush-point","title":"6) Apply commands at a flush point","text":""},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#option-a-manual-flush","title":"Option A \u2014 Manual flush","text":"<pre><code>safeDespawnInsideQuery(world);\nworld.flush(); // apply queued despawns\n</code></pre> <p><code>flush()</code> applies queued commands (and <code>update()</code> also flushes automatically at the end). </p>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#option-b-flush-at-phase-boundaries-recommended","title":"Option B \u2014 Flush at phase boundaries (recommended)","text":"<p>Use <code>Schedule</code>, which flushes after each phase:</p> <pre><code>const sched = new Schedule();\n\nsched.add(world, \"sim\", (w: WorldApi) =&gt; {\n  // move\n  for (const { c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x;\n  }\n});\n\nsched.add(world, \"cleanup\", (w: WorldApi) =&gt; {\n  // safely despawn based on updated positions\n  safeDespawnInsideQuery(w);\n});\n\n// Flush happens after each phase automatically\nconst phases = [\"sim\", \"cleanup\"];\n</code></pre> <p><code>Schedule.run(world, dt, phases)</code> runs phases and calls <code>world.flush()</code> after each phase. </p>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#7-run-a-few-ticks-and-print-whats-left","title":"7) Run a few ticks and print what\u2019s left","text":"<p>Add a small logger:</p> <pre><code>function logPositions(w: WorldApi, label: string) {\n  const items: string[] = [];\n  for (const { e, c1: pos } of w.query(Position)) {\n    items.push(`e${e.id}:${pos.x.toFixed(1)}`);\n  }\n  console.log(label, items.join(\" | \") || \"(none)\");\n}\n</code></pre> <p>Now run:</p> <pre><code>logPositions(world, \"before\");\n\nfor (let i = 0; i &lt; 5; i++) {\n  sched.run(world, 0, phases);\n  logPositions(world, `after tick ${i + 1}`);\n}\n</code></pre>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#8-full-file-copypaste","title":"8) Full file (copy/paste)","text":"<pre><code>import { World, Schedule } from \"archetype-ecs-lib\";\n\nclass Position { constructor(public x = 0) {} }\nclass Velocity { constructor(public x = 0) {} }\n\nconst world = new World();\n\nfunction spawnMover(x: number, vx: number) {\n  const e = world.spawn();\n  world.add(e, Position, new Position(x));\n  world.add(e, Velocity, new Velocity(vx));\n  return e;\n}\n\nspawnMover(0,  2);\nspawnMover(5, -3);\nspawnMover(9,  1);\n\nconst unsafeDespawnInsideQuery: SystemFn = (w) =&gt; {\n  for (const { e, c1: pos } of w.query(Position)) {\n    if (pos.x &gt; 8) {\n      w.despawn(e); // \u274c may throw\n    }\n  }\n}\n\ntry {\n  unsafeDespawnInsideQuery(world as any);\n  console.log(\"unsafe: no error (but still not safe)\");\n} catch (err: any) {\n  console.log(\"unsafe: error as expected -&gt;\", String(err.message ?? err));\n}\n\nconst safeDespawnInsideQuery: SystemFn = (w) =&gt; {\n  for (const { e, c1: pos } of w.query(Position)) {\n    if (pos.x &gt; 8) w.cmd().despawn(e); // \u2705 deferred\n  }\n}\n\nfunction logPositions(w: WorldApi, label: string) {\n  const items: string[] = [];\n  for (const { e, c1: pos } of w.query(Position)) {\n    items.push(`e${e.id}:${pos.x.toFixed(1)}`);\n  }\n  console.log(label, items.join(\" | \") || \"(none)\");\n}\n\nconst sched = new Schedule();\n\nsched.add(world, \"sim\", (w: WorldApi) =&gt; {\n  for (const { c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x;\n  }\n});\n\nsched.add(world, \"cleanup\", (w: WorldApi) =&gt; {\n  safeDespawnInsideQuery(w);\n});\n\nconst phases = [\"sim\", \"cleanup\"];\n\nlogPositions(world, \"before\");\nfor (let i = 0; i &lt; 5; i++) {\n  sched.run(world, 0, phases); // flush after each phase\n  logPositions(world, `after tick ${i + 1}`);\n}\n</code></pre>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#9-run-it","title":"9) Run it","text":"<pre><code>npx tsx tutorial4.ts\n</code></pre> <p>You\u2019ll see:</p> <ul> <li>the unsafe version may throw (depending on timing/guarding)</li> <li>the safe version consistently despawns entities after they cross the threshold</li> <li>phase flush points make the timing predictable </li> </ul>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/","title":"Tutorial 4 \u2014 Writing systems","text":"<p>Outcome: you\u2019ll write real gameplay logic as systems: query components, mutate data safely, and run everything through a Schedule (<code>input \u2192 sim \u2192 cleanup</code>) with automatic <code>flush()</code> between phases. </p>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#1-create-tutorial3ts","title":"1) Create <code>tutorial3.ts</code>","text":"<pre><code>import { World, WorldApi, Schedule, SystemFn } from \"archetype-ecs-lib\";\n</code></pre> <p>The lib exports <code>World</code> and <code>Schedule</code>. </p>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#2-define-components-data-only","title":"2) Define components (data only)","text":"<pre><code>class Position { constructor(public x = 0, public y = 0) {} }\nclass Velocity { constructor(public x = 0, public y = 0) {} }\nclass Lifetime { constructor(public seconds = 1.0) {} } // despawn when &lt;= 0\n</code></pre>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#3-create-a-world-and-spawn-a-few-entities","title":"3) Create a World and spawn a few entities","text":"<pre><code>const world = new World();\n\nfunction spawnMover(x: number, y: number, vx: number, vy: number, life = 2.0) {\n  const e = world.spawn();\n  world.add(e, Position, new Position(x, y));\n  world.add(e, Velocity, new Velocity(vx, vy));\n  world.add(e, Lifetime, new Lifetime(life));\n  return e;\n}\n\nspawnMover(0, 0,  2, 0, 1.2);\nspawnMover(0, 1,  1, 0, 2.5);\nspawnMover(0, 2, -1, 0, 0.8);\n</code></pre> <p>This uses the documented structural ops: <code>spawn()</code> and <code>add()</code>. </p>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#4-system-function-signature-what-you-write","title":"4) System function signature (what you write)","text":"<p>A system is a function called like:</p> <ul> <li><code>(world, dt) =&gt; void</code></li> </ul> <p>Systems are added using <code>world.addSystem()</code> like <code>world.addSystem((w: WorldApi, dt: number) =&gt; ...)</code>. </p> <p>In this tutorial we\u2019ll register systems on a <code>Schedule</code> (phases), but the function shape is the same.</p>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#5-write-your-first-real-system-movement","title":"5) Write your first real system: movement","text":"<p>This system queries <code>Position + Velocity</code> and updates positions.</p> <pre><code>const movementSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {\n  for (const { c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x * dt;\n    pos.y += vel.y * dt;\n  }\n}\n</code></pre> <p>Query rows provide <code>{ e, c1, c2, ... }</code> in the same order as the query arguments. </p>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#6-mutating-data-safely-despawn-using-commands","title":"6) Mutating data safely: despawn using commands","text":"<p>Despawning is a structural change, so do it through <code>cmd()</code> inside systems.</p> <pre><code>const lifetimeSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {\n  for (const { e, c1: life } of w.query(Lifetime)) {\n    life.seconds -= dt;\n    if (life.seconds &lt;= 0) {\n      w.cmd().despawn(e); // safe: deferred\n    }\n  }\n}\n</code></pre>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#7-add-a-small-cleanup-log-system","title":"7) Add a small \u201ccleanup / log\u201d system","text":"<p>We\u2019ll print positions so you can see it running. This does not do structural changes.</p> <pre><code>const logSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {\n  const lines: string[] = [];\n  for (const { e, c1: pos } of w.query(Position)) {\n    lines.push(`e${e.id} @ (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)})`);\n  }\n  console.log(`frame ${frame}: ${lines.join(\" | \")}`);\n}\n</code></pre>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#8-run-systems-via-world-ule-phases","title":"8) Run systems via world, ule (phases)","text":"<ol> <li>Create a schedule</li> <li>Register systems under phases</li> <li>Run phases each tick</li> </ol> <pre><code>const sched = new Schedule();\n\nsched.add(world, \"sim\", movementSystem);\nsched.add(world, \"sim\", lifetimeSystem);\n\n// log in a separate phase so structural changes are already flushed\nlet frameNo = 0;\nsched.add(world, \"cleanup\", (w: WorldApi) =&gt; {\n  frameNo++;\n  logSystem(w, frameNo);\n});\n\nconst phases = [\"sim\", \"cleanup\"];\n</code></pre> <p><code>Schedule.run(world, dt, phases)</code> runs phases in order and calls <code>world.flush()</code> after each phase. </p>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#9-run-the-loop","title":"9) Run the loop","text":"<pre><code>const dt = 1 / 10; // bigger dt so it\u2019s easy to see\nfor (let i = 0; i &lt; 20; i++) {\n  sched.run(world, dt, phases);\n}\n</code></pre>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#10-full-file-copypaste","title":"10) Full file (copy/paste)","text":"<pre><code>import { World, WorldApi, Schedule, SystemFn } from \"archetype-ecs-lib\";\n\nclass Position { constructor(public x = 0, public y = 0) {} }\nclass Velocity { constructor(public x = 0, public y = 0) {} }\nclass Lifetime { constructor(public seconds = 1.0) {} }\n\nconst world = new World();\n\nfunction spawnMover(x: number, y: number, vx: number, vy: number, life = 2.0) {\n  const e = world.spawn();\n  world.add(e, Position, new Position(x, y));\n  world.add(e, Velocity, new Velocity(vx, vy));\n  world.add(e, Lifetime, new Lifetime(life));\n  return e;\n}\n\nspawnMover(0, 0,  2, 0, 1.2);\nspawnMover(0, 1,  1, 0, 2.5);\nspawnMover(0, 2, -1, 0, 0.8);\n\nconst movementSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {\n  for (const { c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x * dt;\n    pos.y += vel.y * dt;\n  }\n}\n\nconst lifetimeSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {\n  for (const { e, c1: life } of w.query(Lifetime)) {\n    life.seconds -= dt;\n    if (life.seconds &lt;= 0) w.cmd().despawn(e);\n  }\n}\n\nconst logSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {\n  const lines: string[] = [];\n  for (const { e, c1: pos } of w.query(Position)) {\n    lines.push(`e${e.id} @ (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)})`);\n  }\n  console.log(`frame ${frame}: ${lines.join(\" | \")}`);\n}\n\nconst sched = new Schedule();\nsched.add(world, \"sim\", movementSystem);\nsched.add(world, \"sim\", lifetimeSystem);\n\nlet frameNo = 0;\nsched.add(world, \"cleanup\", (w: WorldApi) =&gt; {\n  frameNo++;\n  logSystem(w, frameNo);\n});\n\nconst phases = [\"sim\", \"cleanup\"];\n\nconst dt = 1 / 10;\nfor (let i = 0; i &lt; 20; i++) {\n  sched.run(world, dt, phases);\n}\n</code></pre>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#11-run-it","title":"11) Run it","text":"<pre><code>npx tsx tutorial3.ts\n</code></pre> <p>You\u2019ll see entities moving, then disappearing as their <code>Lifetime</code> reaches 0 (despawned safely via commands + phase flush). </p>"},{"location":"Tutorials/Tutorial-5%E2%80%94ECS-%2B-Three.js/","title":"Tutorial 5 \u2014 ECS + Three.js (render-sync + safe spawn/despawn)","text":"<p>Outcome: you\u2019ll see moving cubes in Three.js. You\u2019ll also spawn new cubes on click and despawn them safely using <code>cmd()</code> + phase flush boundaries (via <code>Schedule</code>). </p>"},{"location":"Tutorials/Tutorial-5%E2%80%94ECS-%2B-Three.js/#1-create-a-new-project","title":"1) Create a new project","text":"<pre><code>mkdir ecs-threejs-tutorial\ncd ecs-threejs-tutorial\nnpm init -y\n\nnpm i archetype-ecs-lib three\nnpm i -D vite typescript\n</code></pre> <p>The ECS package is installed as <code>archetype-ecs-lib</code>. </p>"},{"location":"Tutorials/Tutorial-5%E2%80%94ECS-%2B-Three.js/#2-add-indexhtml","title":"2) Add <code>index.html</code>","text":"<p>Create <code>index.html</code>:</p> <pre><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;ECS + Three.js Tutorial&lt;/title&gt;\n    &lt;style&gt;\n      html, body { margin: 0; height: 100%; overflow: hidden; }\n      #hud {\n        position: fixed; left: 12px; top: 12px;\n        padding: 8px 10px; border-radius: 8px;\n        background: rgba(0,0,0,0.55); color: #fff;\n        font-family: system-ui, sans-serif; font-size: 13px;\n        user-select: none;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"hud\"&gt;Click to spawn cubes&lt;/div&gt;\n    &lt;script type=\"module\" src=\"/src/main.ts\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"Tutorials/Tutorial-5%E2%80%94ECS-%2B-Three.js/#3-add-srcmaints","title":"3) Add <code>src/main.ts</code>","text":"<p>Create <code>src/main.ts</code>:</p> <p>```ts linenums=\"false\" import * as THREE from \"three\"; import { World, WorldApi, Schedule, SystemFn } from \"archetype-ecs-lib\";</p> <p>// -------------------- // Components (data only) // -------------------- class Position { constructor(public x = 0, public y = 0, public z = 0) {} } class Velocity { constructor(public x = 0, public y = 0, public z = 0) {} } class Lifetime { constructor(public seconds = 2.0) {} } class Renderable { constructor(public kind: \"cube\" = \"cube\") {} }</p> <p>// -------------------- // Three.js setup // -------------------- const renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement);</p> <p>const scene = new THREE.Scene(); scene.background = new THREE.Color(0x101018);</p> <p>const camera = new THREE.PerspectiveCamera(   60,   window.innerWidth / window.innerHeight,   0.1,   1000 ); camera.position.set(0, 6, 14); camera.lookAt(0, 0, 0);</p> <p>const grid = new THREE.GridHelper(40, 40); scene.add(grid);</p> <p>window.addEventListener(\"resize\", () =&gt; {   camera.aspect = window.innerWidth / window.innerHeight;   camera.updateProjectionMatrix();   renderer.setSize(window.innerWidth, window.innerHeight); });</p> <p>// -------------------- // ECS setup // -------------------- const world = new World(); const sched = new Schedule();</p> <p>// Map ECS entities -&gt; Three.js objects // Use id+gen so reuse of ids never points to the wrong mesh. const entityKey = (e: { id: number; gen: number }) =&gt; <code>${e.id}:${e.gen}</code>; const objects = new Map(); <p>function makeObject(r: Renderable): THREE.Object3D {   // MeshNormalMaterial doesn't need lights   const geo = new THREE.BoxGeometry(1, 1, 1);   const mat = new THREE.MeshNormalMaterial();   const mesh = new THREE.Mesh(geo, mat);   mesh.castShadow = false;   mesh.receiveShadow = false;   return mesh; }</p> <p>// -------------------- // Input: click to spawn // -------------------- let pendingClicks = 0; window.addEventListener(\"pointerdown\", () =&gt; pendingClicks++);</p> <p>const inputPhase: SystemFn = (w: WorldApi) =&gt; {   if (pendingClicks &lt;= 0) return;</p> <p>const cmd = w.cmd();   for (let i = 0; i &lt; pendingClicks; i++) {     cmd.spawn((e: any) =&gt; {       // Spawn near origin with random velocity and short lifetime       const x = (Math.random() - 0.5) * 8;       const z = (Math.random() - 0.5) * 8;</p> <pre><code>  const vx = (Math.random() - 0.5) * 6;\n  const vz = (Math.random() - 0.5) * 6;\n\n  cmd.addBundle(\n    e,\n    [new Position(x, 0.5, z), new Velocity(vx, 0, vz), new Lifetime(2.0 + Math.random() * 2.0), new Renderable(\"cube\")]\n  );\n});\n</code></pre> <p>}</p> <p>pendingClicks = 0; }</p> <p>// -------------------- // Simulation: movement // -------------------- const movementSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {   for (const { c1: pos, c2: vel } of w.query(Position, Velocity)) {     pos.x += vel.x * dt;     pos.y += vel.y * dt;     pos.z += vel.z * dt;</p> <pre><code>// simple bounds bounce\nconst limit = 12;\nif (pos.x &lt; -limit || pos.x &gt; limit) vel.x *= -1;\nif (pos.z &lt; -limit || pos.z &gt; limit) vel.z *= -1;\n</code></pre> <p>} }</p> <p>// -------------------- // Simulation: lifetime -&gt; despawn (deferred) // -------------------- const lifetimeSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {   for (const { e, c1: life } of w.query(Lifetime)) {     life.seconds -= dt;     if (life.seconds &lt;= 0) {       w.cmd().despawn(e); // structural change deferred     }   } }</p> <p>// -------------------- // Render phase: ECS -&gt; Three.js sync + remove despawned // -------------------- const renderSync: SystemFn = (w: WorldApi) =&gt; {   const alive = new Set(); <p>// Create/update objects for all renderables   for (const { e, c1: pos, c2: rend } of w.query(Position, Renderable)) {     const key = entityKey(e);     alive.add(key);</p> <pre><code>let obj = objects.get(key);\nif (!obj) {\n  obj = makeObject(rend);\n  scene.add(obj);\n  objects.set(key, obj);\n}\n\nobj.position.set(pos.x, pos.y, pos.z);\n</code></pre> <p>}</p> <p>// Remove objects whose entities are gone   for (const [key, obj] of objects) {     if (!alive.has(key)) {       scene.remove(obj);       objects.delete(key);     }   } }</p> <p>// -------------------- // Schedule: phase ordering + flush boundaries // -------------------- // Schedule runs phases in order and calls world.flush() after each phase. :contentReference[oaicite:2]{index=2} sched.add(world, \"input\", inputPhase); sched.add(world, \"sim\", movementSystem); sched.add(world, \"sim\", lifetimeSystem); sched.add(world, \"render\", renderSync);</p> <p>const phases = [\"input\", \"sim\", \"render\"];</p> <p>// -------------------- // Animation loop // -------------------- let last = performance.now();</p> <p>function frame(now: number) {   const dt = Math.min(0.05, (now - last) / 1000);   last = now;</p> <p>// Run ECS phases (flush after each phase)   sched.run(world, dt, phases);</p> <p>// Render Three.js   renderer.render(scene, camera);</p> <p>requestAnimationFrame(frame); }</p> <p>requestAnimationFrame(frame);</p> <p>// Spawn a few cubes at start (via commands so it behaves like gameplay) pendingClicks = 6; <pre><code>This uses:\n\n* `Schedule.add(phase, fn)` and `Schedule.run(world, dt, phases)` with flush between phases \n* `world.query(A, B)` yielding `{ e, c1, c2 }` \n* deferred structural ops via `cmd().spawn/add/despawn` \n\n---\n\n## 4) Run it\n\n```bash\nnpx vite\n</code></pre></p> <p>Open the local URL Vite prints.</p>"},{"location":"Tutorials/Tutorial-5%E2%80%94ECS-%2B-Three.js/#5-what-to-try-hands-on","title":"5) What to try (hands-on)","text":"<ol> <li>Click to spawn cubes</li> <li>Watch them move (ECS <code>Position</code> + <code>Velocity</code>)</li> <li>Watch them disappear after a few seconds (<code>Lifetime</code> \u2192 <code>cmd().despawn(e)</code>), and see the Three.js mesh removed automatically in <code>renderSync()</code>.</li> </ol> <p>That\u2019s the \u201csafe loop\u201d:</p> <ul> <li>structural requests happen inside systems using <code>cmd()</code></li> <li>structural changes become real at flush boundaries (Schedule phases)</li> <li>render-sync runs on a stable world snapshot </li> </ul>"},{"location":"Tutorials/Tutorial-6%E2%80%94Save-and-load/","title":"Tutorial 6 \u2014 Save and load","text":"<p>Outcome: you will build a tiny save/load loop with <code>World.snapshot()</code> and <code>World.restore()</code>.</p>"},{"location":"Tutorials/Tutorial-6%E2%80%94Save-and-load/#1-create-tutorial6ts","title":"1) Create <code>tutorial6.ts</code>","text":"<pre><code>import {\n    World,\n    type ComponentCtor,\n    type SnapshotCodec,\n    type WorldSnapshot\n} from \"archetype-ecs-lib\";\n</code></pre>"},{"location":"Tutorials/Tutorial-6%E2%80%94Save-and-load/#2-define-components-and-resources","title":"2) Define components and resources","text":"<pre><code>class Position {\n    constructor(public x = 0, public y = 0) {}\n}\n\nclass Health {\n    constructor(public hp = 100) {}\n}\n\nclass RunState {\n    constructor(public wave = 1, public score = 0) {}\n}\n\ntype SpawnRules = { cooldown: number };\nconst SpawnRulesToken = (() =&gt; ({ cooldown: 1.0 })) as ComponentCtor&lt;SpawnRules&gt;;\n</code></pre>"},{"location":"Tutorials/Tutorial-6%E2%80%94Save-and-load/#3-create-world-and-register-snapshot-codecs","title":"3) Create world and register snapshot codecs","text":"<pre><code>const world = new World();\n\nconst positionCodec: SnapshotCodec&lt;Position, { x: number; y: number }&gt; = {\n    key: \"comp.position\",\n    serialize: (v) =&gt; ({ x: v.x, y: v.y }),\n    deserialize: (d) =&gt; new Position(d.x, d.y),\n};\n\nconst healthCodec: SnapshotCodec&lt;Health, { hp: number }&gt; = {\n    key: \"comp.health\",\n    serialize: (v) =&gt; ({ hp: v.hp }),\n    deserialize: (d) =&gt; new Health(d.hp),\n};\n\nconst runStateCodec: SnapshotCodec&lt;RunState, { wave: number; score: number }&gt; = {\n    key: \"res.run-state\",\n    serialize: (v) =&gt; ({ wave: v.wave, score: v.score }),\n    deserialize: (d) =&gt; new RunState(d.wave, d.score),\n};\n\nconst spawnRulesCodec: SnapshotCodec&lt;SpawnRules, { cooldown: number }&gt; = {\n    key: \"res.spawn-rules\",\n    serialize: (v) =&gt; ({ cooldown: v.cooldown }),\n    deserialize: (d) =&gt; ({ cooldown: d.cooldown }),\n};\n\nworld.registerComponentSnapshot(Position, positionCodec);\nworld.registerComponentSnapshot(Health, healthCodec);\nworld.registerResourceSnapshot(RunState, runStateCodec);\nworld.registerResourceSnapshot(SpawnRulesToken, spawnRulesCodec);\n</code></pre>"},{"location":"Tutorials/Tutorial-6%E2%80%94Save-and-load/#4-bootstrap-some-game-state","title":"4) Bootstrap some game state","text":"<pre><code>world.setResource(RunState, new RunState(3, 1200));\nworld.setResource(SpawnRulesToken, { cooldown: 0.5 });\n\nconst e = world.spawn();\nworld.add(e, Position, new Position(10, 20));\nworld.add(e, Health, new Health(75));\n</code></pre>"},{"location":"Tutorials/Tutorial-6%E2%80%94Save-and-load/#5-save","title":"5) Save","text":"<pre><code>const snapshotA = world.snapshot();\nconst json = JSON.stringify(snapshotA);\nconsole.log(\"Saved bytes:\", json.length);\n</code></pre>"},{"location":"Tutorials/Tutorial-6%E2%80%94Save-and-load/#6-mutate-state-simulate-gameplay","title":"6) Mutate state (simulate gameplay)","text":"<pre><code>const pos = world.get(e, Position)!;\npos.x = 99;\npos.y = 42;\n\nworld.requireResource(RunState).score += 300;\n</code></pre>"},{"location":"Tutorials/Tutorial-6%E2%80%94Save-and-load/#7-load","title":"7) Load","text":"<pre><code>const loaded = JSON.parse(json) as WorldSnapshot;\nworld.restore(loaded);\n</code></pre> <p>After restore, you get the original values from step 4:</p> <pre><code>console.log(world.get(e, Position)); // Position { x: 10, y: 20 }\nconsole.log(world.requireResource(RunState)); // RunState { wave: 3, score: 1200 }\n</code></pre>"},{"location":"Tutorials/Tutorial-6%E2%80%94Save-and-load/#8-useful-pattern-baseline-quick-save","title":"8) Useful pattern: baseline + quick save","text":"<pre><code>const baseline = world.snapshot();\nlet quickSave: WorldSnapshot | null = null;\n\nfunction saveNow() {\n    quickSave = world.snapshot();\n}\n\nfunction loadNow() {\n    if (quickSave) world.restore(quickSave);\n}\n\nfunction resetRun() {\n    world.restore(baseline);\n}\n</code></pre>"},{"location":"Tutorials/Tutorial-6%E2%80%94Save-and-load/#9-what-to-remember","title":"9) What to remember","text":"<ul> <li>Register codecs before calling <code>restore</code>.</li> <li>Save files are plain data; systems/schedules are rebuilt by normal app boot code.</li> <li>Keep codec keys stable (<code>\"comp.*\"</code> / <code>\"res.*\"</code>) for long-term compatibility.</li> </ul>"}]}