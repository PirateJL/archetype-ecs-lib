{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#archetype-ecs-lib","title":"Archetype ECS Lib","text":"<p>A tiny archetype based ECS (Entity Component System) for TypeScript.</p> <p>This documentation is split into 4 parts :</p> <ul> <li>Explanation of the general operation of the library</li> <li>Find information in the Reference</li> <li>Target a specific goal using the How-To Guides</li> <li>Learn through the Tutorials: step-by-step guidance</li> </ul>"},{"location":"#install","title":"Install","text":"<p>NPM package available here</p> <pre><code>npm i archetype-ecs-lib\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>import { World, Schedule } from \"archetype-ecs-lib\";\n\nclass Position { constructor(public x = 0, public y = 0) {} }\nclass Velocity { constructor(public x = 0, public y = 0) {} }\n\nconst world = new World();\n\n// Spawn immediately\nconst e = world.spawn();\nworld.add(e, Position, new Position(0, 0));\nworld.add(e, Velocity, new Velocity(1, 0));\n\n// A simple system\nworld.addSystem((w) =&gt; {\n  for (const { e, c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x * dt;\n    pos.y += vel.y * dt;\n\n    // Defer structural changes safely\n    if (pos.x &gt; 10) w.cmd().despawn(e);\n  }\n});\n\nworld.update(1 / 60);\n</code></pre> <p>Note: <code>SystemFn</code> is typed as <code>(world: WorldApi, dt) =&gt; void</code>. Checkout the tutorials for more!  </p>"},{"location":"#notes-limitations","title":"Notes &amp; limitations","text":"<ul> <li>This is intentionally minimal: no parallelism, no borrow-checking, no automatic conflict detection.</li> <li>Query results use <code>c1/c2/...</code> fields for stability and speed; you can wrap this in helpers if you prefer tuple returns.</li> <li><code>TypeId</code> assignment is process-local and based on constructor identity (<code>WeakMap</code>).</li> </ul>"},{"location":"#license","title":"License","text":"<p>This code is distributed under the terms and conditions of the MIT license.</p>"},{"location":"Demo/","title":"Demo","text":"<p>Here is a small representtion example using the library. The frontend were build with Vite</p> <p>Open demo in a new tab</p>"},{"location":"Explanation/ecs-and-the-game-loop/","title":"ECS and the game loop","text":"<p>ECS is best understood as the way you organize game state and game logic, not as the thing that does everything. In a typical game, the loop still has input, rendering, audio, physics, networking, etc. ECS provides a consistent place for runtime data (components) and behavior (systems), plus a schedule that defines when that behavior runs. This library already models this explicitly with <code>World.update(dt)</code> and with a phase-based <code>Schedule</code> that flushes between phases. </p>"},{"location":"Explanation/ecs-and-the-game-loop/#frame-phases","title":"Frame phases","text":"<p>A \u201cframe\u201d is rarely just \u201cupdate then draw\u201d. Most games are structured in phases, even if informally. A common conceptual breakdown:</p> <ol> <li>Input: read devices/events, translate into game intent</li> <li>Simulation: movement, AI, gameplay rules, timers</li> <li>Physics (optional separate step): integrate, solve collisions, constraints</li> <li>Post-sim: resolve gameplay outcomes, spawn/despawn, apply state transitions</li> <li>Render prep: build renderable data, sort, cull</li> <li>Render: submit to GPU / engine renderer</li> <li>End-of-frame: cleanup, present frame, etc.</li> </ol> <p>The <code>Schedule</code> is designed exactly for this idea: you define phases (strings) and run them in order, with <code>flush()</code> after each phase. </p>"},{"location":"Explanation/ecs-and-the-game-loop/#where-ecs-fits","title":"Where ECS fits","text":"<p>ECS typically fits in the simulation and render-prep parts of the loop:</p> <ul> <li>World holds the mutable runtime state (entities + components) </li> <li>Systems implement the game logic by querying components and mutating them</li> <li>Commands allow safe structural changes during those systems (<code>cmd()</code> \u2192 <code>flush()</code>) </li> <li>Schedule provides deterministic ordering and safe mutation boundaries between phases </li> </ul> <p>A useful mental model:</p> <ul> <li>Rendering engines want a renderable snapshot (meshes, transforms, materials, draw lists).</li> <li>Input systems produce intent/state (move left, fire, target position).</li> <li>Physics engines operate on physical representations (bodies, colliders).</li> </ul> <p>ECS sits in the middle coordinating these, not replacing them.</p>"},{"location":"Explanation/ecs-and-the-game-loop/#a-concrete-mapping-using-this-primitives","title":"A concrete mapping using this primitives","text":"<ul> <li>Input phase: read input \u2192 write <code>InputState</code> component / resource \u2192 enqueue spawns/despawns if needed</li> <li><code>flush()</code></li> <li>Sim phase: run movement/AI/gameplay using queries \u2192 update <code>Position</code>, <code>Velocity</code>, etc.</li> <li><code>flush()</code></li> <li>Render phase: build lightweight render data (<code>RenderTransform</code>, <code>Visible</code>, etc.) \u2192 hand off to renderer</li> </ul> <p>This is why \u201cflush points\u201d exist in an ECS schedule: they define when the world structure is allowed to change and when the next phase sees those changes. </p>"},{"location":"Explanation/ecs-and-the-game-loop/#why-ecs-does-not-replace-rendering-input-or-physics-engines","title":"Why ECS does not replace rendering, input, or physics engines","text":""},{"location":"Explanation/ecs-and-the-game-loop/#rendering","title":"Rendering","text":"<p>A renderer is a specialized pipeline:</p> <ul> <li>GPU resources, shaders, batching, sorting, culling</li> <li>frame graph / render passes</li> <li>platform-specific backends</li> </ul> <p>ECS is not a GPU pipeline. What ECS does well is:</p> <ul> <li>storing render-related data as components (<code>Transform</code>, <code>Renderable</code>, <code>MaterialRef</code>, etc.)</li> <li>running systems that prepare and synchronize data for the renderer</li> </ul> <p>So ECS often produces a render list or updates engine scene objects, but the renderer still does the rendering.</p>"},{"location":"Explanation/ecs-and-the-game-loop/#input","title":"Input","text":"<p>Input is inherently eventful and platform-driven:</p> <ul> <li>OS/window events</li> <li>device state polling</li> <li>mapping raw events to game actions</li> </ul> <p>ECS can store input state (<code>InputAxis</code>, <code>ActionPressed</code>, etc.) and process it in systems, but it doesn\u2019t replace the platform input layer. In practice:</p> <ul> <li>platform collects input</li> <li>ECS system transforms it into gameplay-friendly state</li> </ul>"},{"location":"Explanation/ecs-and-the-game-loop/#physics","title":"Physics","text":"<p>Physics engines are optimized solvers:</p> <ul> <li>broadphase / narrowphase collision detection</li> <li>integrators and constraint solvers</li> <li>continuous collision, joints, sleeping, etc.</li> </ul> <p>ECS can represent physics data (mass, collider type, desired forces) and drive the physics engine, but the solver itself is a dedicated subsystem.</p> <p>A common integration pattern:</p> <ul> <li>ECS \u2192 write forces/desired velocity into physics engine</li> <li>Physics step happens</li> <li>Physics results \u2192 write back transforms/velocities into ECS</li> </ul>"},{"location":"Explanation/ecs-and-the-game-loop/#the-key-idea-ecs-is-the-coordination-model","title":"The key idea: ECS is the coordination model","text":"<p>ECS shines when you treat it as:</p> <ul> <li>a data model for game state (components)</li> <li>a behavior model for game logic (systems)</li> <li>an execution model for ordering (schedule + phases + flush points) </li> </ul> <p>But rendering/input/physics are specialized domains with their own constraints and pipelines. ECS coordinates them by being the \u201ctruth\u201d for game state and by running the logic that translates between subsystems.</p>"},{"location":"Explanation/integrating-an-ecs-with-three.js/","title":"Integrating an ECS with Three.js","text":"<p>Three.js is a rendering engine (scene graph + GPU submission). This ECS is a simulation architecture (data in components, behavior in systems, ordered by a schedule, with safe structural changes via deferred commands + flush points). Integrating them well means letting each do what it\u2019s good at, and defining clean \u201chand-off\u201d boundaries.</p>"},{"location":"Explanation/integrating-an-ecs-with-three.js/#the-mental-model-ecs-drives-state-threejs-draws-it","title":"The mental model: ECS drives state, Three.js draws it","text":"<p>A practical split that scales:</p> <ul> <li>ECS World = authoritative game/sim state (position, velocity, health, selection, etc.) </li> <li>Three.js Scene = visual representation (Object3D transforms, meshes, materials, lights)</li> </ul> <p>So the goal is not \u201cput Three.js inside ECS\u201d, but:</p> <p>Systems write simulation state \u2192 a render-sync step pushes that state into Three.js objects.</p>"},{"location":"Explanation/integrating-an-ecs-with-three.js/#where-ecs-fits-in-the-threejs-render-loop","title":"Where ECS fits in the Three.js render loop","text":"<p>Three.js typically runs:</p> <ol> <li>update (your code)</li> <li><code>renderer.render(scene, camera)</code></li> </ol> <p>With ECS, your \u201cupdate\u201d becomes scheduled phases, e.g.:</p> <ul> <li><code>input</code> (read DOM/input, write components/resources)</li> <li><code>sim</code> (gameplay, movement, AI)</li> <li><code>render</code> (sync ECS \u2192 Three.js, then render)</li> </ul> <p>The <code>Schedule</code> already supports this exact idea and flushes commands between phases to make entity/component creation/removal deterministic.</p>"},{"location":"Explanation/integrating-an-ecs-with-three.js/#why-flush-points-matter-for-threejs-integration","title":"Why flush points matter for Three.js integration","text":"<p>Spawning/despawning and add/remove are structural changes in this ECS and are expected to be deferred while iterating queries/systems.</p> <p>That maps perfectly to Three.js object lifecycle:</p> <ul> <li>During sim: decide \u201cthis entity should appear/disappear\u201d \u2192 enqueue ECS commands</li> <li>At flush boundary: ECS structure becomes stable</li> <li>Render-sync phase: create/remove corresponding <code>Object3D</code> safely, because you\u2019re no longer mid-iteration on archetype tables</li> </ul> <p>This is the same reason this ECS has <code>cmd()</code> / <code>flush()</code> and why <code>Schedule</code> flushes between phases.</p>"},{"location":"Explanation/integrating-an-ecs-with-three.js/#a-clean-integration-pattern-renderable-bridge-components","title":"A clean integration pattern: \u201cRenderable bridge\u201d components","text":"<p>Common approach:</p> <ul> <li>A <code>Transform</code> component (position/rotation/scale) is owned by ECS.</li> <li>A <code>Renderable</code> component carries a reference/handle to what Three.js should draw (mesh id, model key, material key\u2026).</li> <li>A render-sync system queries <code>(Transform, Renderable)</code> and applies changes to the corresponding <code>Object3D</code>.</li> </ul> <p>Key idea: ECS components store \u201cwhat it is\u201d and \u201cwhere it is\u201d, while the actual <code>Mesh/Object3D</code> lives in Three.js.</p> <p>This keeps:</p> <ul> <li>ECS portable (not tied to Three.js types everywhere)</li> <li>Three.js free to manage GPU resources</li> </ul>"},{"location":"Explanation/integrating-an-ecs-with-three.js/#one-way-vs-two-way-sync-pick-a-source-of-truth","title":"One-way vs two-way sync (pick a source of truth)","text":"<p>Integration gets messy when both ECS and Three.js \u201cown\u201d transforms.</p> <p>A scalable default:</p> <ul> <li>ECS is the source of truth for gameplay transforms.</li> <li>Three.js <code>Object3D</code> is just the projection of that state.</li> </ul> <p>Only do two-way sync when you truly need it (editor gizmos, drag interactions). Even then, treat it as a controlled input step:</p> <ul> <li>read Object3D change in <code>input</code> or <code>tools</code> phase</li> <li>write back to ECS components</li> <li>let sim proceed from ECS again</li> </ul>"},{"location":"Explanation/integrating-an-ecs-with-three.js/#why-ecs-does-not-replace-threejs-and-shouldnt-try","title":"Why ECS does not replace Three.js (and shouldn\u2019t try)","text":"<p>Even with a \u201cfull ECS\u201d architecture, Three.js still owns:</p> <ul> <li>scene graph concerns (parenting, cameras, lights)</li> <li>GPU resource lifetimes (buffers, textures, materials)</li> <li>draw submission, sorting, batching, culling strategies</li> </ul> <p>ECS complements that by making simulation state and logic scalable: archetype tables + queries + systems + scheduling.</p>"},{"location":"Explanation/integrating-an-ecs-with-three.js/#scaling-tips-when-entity-counts-grow","title":"Scaling tips (when entity counts grow)","text":"<p>When you have many similar visuals:</p> <ul> <li>prefer InstancedMesh in Three.js</li> <li>let ECS systems produce instance transforms (dense arrays) from queries</li> <li>upload those transforms once per frame</li> </ul> <p>This aligns with why archetype ECS exists: tight iteration over dense component columns. </p>"},{"location":"Explanation/meaning-of-ecs/","title":"What people mean by a \u201cfull ECS\u201d","text":"<p>\u201cECS\u201d can mean just a storage model (entities + components in some container), or it can mean an entire game/app architecture where most runtime state and behavior flows through an ECS world + schedule + systems.</p> <p>A \u201cfull ECS\u201d is typically an architecture where:</p> <ul> <li>Entities are only IDs/handles (no behavior).</li> <li>Components are only data.</li> <li>Systems are where behavior lives (pure-ish functions operating on data).</li> <li>A World is the single source of truth for runtime state.</li> <li>A Scheduler (or \u201capp loop\u201d) defines when systems run and in what order.</li> <li>Structural changes are controlled (often via a command buffer) so iteration stays safe and fast.</li> </ul> <p>This library already contains several \u201cfull ECS\u201d building blocks: archetype tables (SoA), queries, deferred commands, and a phase-based schedule. </p> <p>What makes it \u201cfull\u201d is less \u201cdo you use archetypes?\u201d and more \u201cdoes the ECS define the whole program\u2019s execution model?\u201d</p>"},{"location":"Explanation/meaning-of-ecs/#ecs-as-architecture-not-just-storage","title":"ECS as architecture, not just storage","text":""},{"location":"Explanation/meaning-of-ecs/#storage-only-ecs-not-full","title":"Storage-only ECS (not \u201cfull\u201d)","text":"<p>This is common in small libs or quick implementations:</p> <ul> <li>Entities: IDs</li> <li>Components: data bags</li> <li>\u201cSystems\u201d: often just loops in user code</li> <li>Little/no scheduling model</li> <li>No consistent lifecycle for input \u2192 simulation \u2192 rendering</li> <li>Structural changes are ad-hoc</li> </ul> <p>You can build a game with this, but the ECS isn\u2019t the organizing principle\u2014it\u2019s a container.</p>"},{"location":"Explanation/meaning-of-ecs/#architecture-ecs-full-ecs","title":"Architecture ECS (\u201cfull ECS\u201d)","text":"<p>Here, ECS is the spine of the app:</p> <ul> <li>There\u2019s a main schedule (often phases like <code>input \u2192 sim \u2192 render</code>).</li> <li>Systems are registered, ordered, and executed consistently each tick.</li> <li>Cross-cutting state is handled intentionally (resources/singletons, events, time, config).</li> <li>Structural changes are made safe/deterministic (command buffers, flush points).</li> <li>You get a uniform pattern for new features: \u201cadd data + add system\u201d.</li> </ul> <p>The <code>Schedule</code> explicitly models phase ordering + flush barriers, which is a key \u201carchitecture ECS\u201d ingredient. </p>"},{"location":"Explanation/meaning-of-ecs/#difference-between-a-library-ecs-and-an-engine-ecs","title":"Difference between a library ECS and an engine ECS","text":""},{"location":"Explanation/meaning-of-ecs/#library-ecs","title":"Library ECS","text":"<p>Goal: provide core ECS mechanics.</p> <p>Typical traits:</p> <ul> <li>Focus on storage + query performance (archetypes/SoA) </li> <li>Minimal assumptions about the rest of the program</li> <li>Simple scheduling (or none), often single-threaded</li> <li>You (the user) integrate input, rendering, physics, assets, scenes, etc.</li> </ul>"},{"location":"Explanation/meaning-of-ecs/#engine-ecs-bevy-unity-dots-etc","title":"Engine ECS (Bevy / Unity DOTS / etc.)","text":"<p>Goal: ECS is the entire runtime framework.</p> <p>Engine ECS usually includes (beyond a library):</p> <ul> <li>A full app lifecycle (startup, update, fixed update, shutdown)</li> <li>Integrated input, rendering, audio, physics, animation, UI</li> <li>Asset pipeline + hot reload + serialization</li> <li>Advanced scheduling: dependency graphs, system sets, run criteria, fixed timesteps</li> <li>Often parallel execution + conflict detection</li> <li>Tooling/editor integration</li> </ul> <p>So: library ECS = the \u201cECS core\u201d. engine ECS = ECS core + everything around it, with ECS as the central organizing model.</p>"},{"location":"Explanation/why-archetype-ecs/","title":"Why archetype ECS?","text":"<p>An archetype ECS organizes entities into tables where every entity in a table shares the same component set, stored in SoA form (one column per component). This library explicitly follows this model: \u201cArchetypes (tables) store entities in a SoA layout\u2026 Queries iterate matching archetypes efficiently\u2026 Commands defer structural changes\u2026\u201d </p> <p>The \u201cwhy\u201d is mostly about making the common case (systems that iterate lots of entities with the same components) extremely fast and predictable.</p>"},{"location":"Explanation/why-archetype-ecs/#cache-locality","title":"Cache locality","text":"<p>Most game/sim systems look like:</p> <ul> <li>\u201cfor all entities with <code>Position</code> and <code>Velocity</code>, update position\u201d</li> <li>\u201cfor all entities with <code>Transform</code> and <code>Renderable</code>, build render data\u201d</li> </ul> <p>With archetypes, those entities live together in a table, and each component is a dense column:</p> <ul> <li><code>Position[]</code> contiguous</li> <li><code>Velocity[]</code> contiguous</li> </ul> <p>So the CPU reads memory sequentially, which is what caches and prefetchers love. That\u2019s the practical meaning of cache locality: fewer cache misses, more work per nanosecond.</p> <p>In the library, this is literally the storage promise: SoA archetype tables + queries over matching archetypes. </p>"},{"location":"Explanation/why-archetype-ecs/#branch-elimination-and-no-join-iteration","title":"Branch elimination (and \u201cno-join\u201d iteration)","text":"<p>In many ECS designs, the core loop must constantly ask:</p> <ul> <li>\u201cdoes this entity have Velocity?\u201d</li> <li>\u201cif yes, fetch it; if not, skip\u201d</li> </ul> <p>That creates branches and scattered memory access.</p> <p>With archetypes, the membership check is moved up:</p> <ol> <li>pick archetypes that already contain all required components</li> <li>iterate their rows</li> </ol> <p>Inside the inner loop, there\u2019s no per-entity \u201chas component?\u201d branching\u2014every row is guaranteed to match. The API reflects that by querying required component types and yielding direct component references (<code>c1</code>, <code>c2</code>, \u2026). </p> <p>This is what people mean by branch elimination in archetype ECS: fewer conditional checks in the hot loop, more straight-line code.</p>"},{"location":"Explanation/why-archetype-ecs/#predictable-iteration","title":"Predictable iteration","text":"<p>Archetype iteration tends to be predictable because:</p> <ul> <li>You iterate dense arrays (rows/columns), not sparse IDs.</li> <li>Results are shaped consistently (<code>e</code>, <code>c1</code>, <code>c2</code>, \u2026 in argument order). </li> <li>Structural changes are controlled: this library emphasizes deferring structural changes via <code>cmd()</code> and applying them at <code>flush()</code> points. </li> <li><code>Schedule</code> adds explicit \u201cphase barriers\u201d by flushing between phases, making the world structure stable during each phase\u2019s iteration. </li> </ul> <p>That predictability is less about \u201cdeterministic order of entities\u201d and more about deterministic rules for when the world can change shape.</p>"},{"location":"Explanation/why-archetype-ecs/#comparison-with-sparse-set-ecs","title":"Comparison with sparse-set ECS","text":"<p>A sparse-set ECS typically stores each component type separately (often as a dense array + sparse index by entity id). It\u2019s excellent for:</p> <ul> <li>fast lookup for a single component type (<code>Position</code> alone)</li> <li>cheap per-component iteration</li> <li>simple storage and often cheaper structural changes for single components</li> </ul> <p>But when a system needs multiple components (<code>Position + Velocity + Mass + Forces</code>), sparse-set often needs some form of join:</p> <ul> <li>iterate one component pool, check membership in the others</li> <li>or intersect sets / hop through indirections</li> </ul> <p>That can introduce:</p> <ul> <li>more branching (<code>if has(...)</code>)</li> <li>more random memory access (chasing indices across pools)</li> </ul> <p>Archetypes flip that trade-off:</p> <ul> <li>multi-component iteration is the \u201chappy path\u201d (no join inside the hot loop)</li> <li>but structural changes can be more expensive because adding/removing a component may move an entity between tables. </li> </ul>"},{"location":"Explanation/why-archetype-ecs/#rule-of-thumb","title":"Rule of thumb","text":"<ul> <li>If your game spends most time in systems that read/write several components per entity, archetypes tend to shine.</li> <li>If your workload is lots of single-component iteration and high churn (constant add/remove), sparse-set can be simpler and sometimes cheaper.</li> </ul>"},{"location":"Explanation/why-archetype-ecs/#the-real-trade-off-why-its-not-always-archetypes","title":"The real trade-off (why it\u2019s not \u201calways archetypes\u201d)","text":"<p>Archetype ECS wins by making the hot loops fast, but it pays for it with:</p> <ul> <li>structural churn cost (moving entities between tables on add/remove)</li> <li>many archetypes if you have lots of component combinations</li> <li>a stronger need for command buffering + flush boundaries to keep iteration safe. </li> </ul> <p>That\u2019s why a \u201cfull ECS\u201d architecture often includes commands + scheduling: it\u2019s the natural partner to archetype storage.</p>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/","title":"Why deferred commands exist in an archetype ECS","text":"<p>In an archetype ECS, deferred commands (a command buffer) are not a \u201cnice-to-have\u201d. They exist because the fastest storage model makes certain mutations unsafe during iteration. The library API expresses this directly with <code>world.cmd()</code>, <code>world.flush()</code>, and <code>Schedule.run(...)/flush barriers</code>. </p>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#archetypes-are-tables-and-queries-walk-those-tables","title":"Archetypes are tables, and queries walk those tables","text":"<p>An archetype ECS stores entities in tables:</p> <ul> <li>one archetype = one component set</li> <li>one row = one entity</li> <li>one column per component type (SoA) </li> </ul> <p>A query like <code>world.query(Position, Velocity)</code> does not \u201cscan entities\u201d. It first selects archetypes that contain the required component columns, then iterates dense rows in those tables. </p> <p>This density is where the performance comes from.</p>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#the-core-problem-structural-changes-move-entities-between-tables","title":"The core problem: structural changes move entities between tables","text":"<p>A structural change is anything that changes the component set of an entity:</p> <ul> <li><code>spawn()</code></li> <li><code>despawn(e)</code></li> <li><code>add(e, Ctor, value)</code></li> <li><code>remove(e, Ctor)</code></li> </ul> <p>In an archetype ECS, <code>add/remove</code> usually means:</p> <ol> <li>remove the entity\u2019s row from its current archetype table</li> <li>insert a row into another archetype table</li> <li>update internal bookkeeping (where the entity lives now)</li> </ol> <p>That is fundamentally different from <code>set(e, Ctor, value)</code>, which just updates a value inside the same row/column.</p> <p>So: structural change = table move.</p>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#why-its-unsafe-to-do-structural-changes-during-a-query","title":"Why it\u2019s unsafe to do structural changes during a query","text":"<p>When you iterate a query, you are conceptually doing:</p> <ul> <li>\u201cfor each matching archetype table\u201d</li> <li>\u201cfor each row index in that table\u201d</li> <li>\u201cread columns at that row\u201d</li> </ul> <p>If you structurally change any entity during this loop, you can break the iteration invariants:</p>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#1-swap-remove-can-invalidate-the-current-row","title":"1) Swap-remove can invalidate the current row","text":"<p>Many archetype implementations remove rows with swap-remove (O(1)): the last row is swapped into the removed row index.</p> <p>If you remove entity A at row <code>i</code>, entity B may be swapped into row <code>i</code>.</p> <ul> <li>If your loop then increments <code>i</code>, entity B might be skipped.</li> <li>Or processed twice depending on iteration strategy.</li> </ul>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#2-moving-entities-changes-which-archetypes-match","title":"2) Moving entities changes which archetypes match","text":"<p>Adding/removing a component can move an entity into or out of the set of archetypes that the query is iterating.</p> <p>If you mutate membership while iterating:</p> <ul> <li>you can end up iterating an archetype that didn\u2019t exist in the matching set at the start</li> <li>or miss entities that moved into a matching archetype</li> </ul>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#3-internal-indices-can-become-stale-mid-loop","title":"3) Internal indices can become stale mid-loop","text":"<p>The library <code>World</code> tracks where an entity lives (which archetype + row). A structural change updates those indices. If you mutate while holding references from the iteration, you can end up with:</p> <ul> <li>stale row pointers</li> <li>stale bookkeeping</li> <li>inconsistent state if multiple mutations occur</li> </ul> <p>Even if you \u201cthink it works\u201d, it\u2019s fragile and will eventually bite.</p>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#deferred-commands-are-the-solution-separate-readiterate-from-mutate-structure","title":"Deferred commands are the solution: separate \u201cread/iterate\u201d from \u201cmutate structure\u201d","text":"<p>A command buffer enforces a clean two-step model:</p> <ol> <li>During iteration: read data, compute decisions, mutate component values (safe)</li> <li>At a safe boundary: apply structural changes in a batch (safe)</li> </ol> <p>That\u2019s exactly what the library documents:</p> <ul> <li><code>world.cmd()</code> enqueues structural operations </li> <li><code>world.flush()</code> applies queued commands </li> <li><code>world.update(dt)</code> runs systems, then flushes at frame end </li> <li><code>Schedule.run(...)</code> flushes between phases, providing deterministic barriers </li> </ul> <p>This is why deferred commands exist: they preserve iteration correctness without giving up table-based performance.</p>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#why-flushing-in-phases-is-architecturally-important","title":"Why flushing in phases is architecturally important","text":"<p>The library <code>Schedule</code> explicitly flushes after each phase. </p> <p>This is not just \u201cnice ordering\u201d. It creates deterministic points where the world\u2019s structure is allowed to change.</p> <p>Example mental model:</p> <ul> <li>Input phase: decide spawns/despawns based on input \u2192 enqueue commands</li> <li>Flush: apply those spawns so they exist for simulation</li> <li>Simulation phase: move things, detect collisions \u2192 enqueue structural changes</li> <li>Flush: apply spawns/despawns/removals before render</li> <li>Render phase: build render data from a stable world snapshot</li> </ul> <p>That separation reduces \u201caction at a distance\u201d bugs and makes debugging easier:</p> <ul> <li>\u201cwhy does entity exist in sim but not render?\u201d \u2192 check which phase flushed it.</li> </ul>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#what-you-gain-by-deferring","title":"What you gain by deferring","text":""},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#correctness","title":"Correctness","text":"<ul> <li>No skipped entities</li> <li>No double-processing due to swap-remove effects</li> <li>Stable iteration semantics</li> </ul>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#determinism","title":"Determinism","text":"<ul> <li>Structural changes occur at explicit boundaries</li> <li>Easier to reason about ordering</li> </ul>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#performance","title":"Performance","text":"<ul> <li>Keeps archetype iteration tight and cache-friendly</li> <li>Batching structural operations reduces churn</li> </ul>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#what-to-do-inside-a-system","title":"What to do inside a system","text":"<p>Inside a system (or a query loop), follow this rule:</p> <ul> <li>\u2705 mutate component values directly (e.g. <code>pos.x += ...</code>)</li> <li>\u2705 enqueue structural changes via <code>cmd()</code></li> <li>\u274c don\u2019t call structural <code>World</code> ops directly mid-iteration</li> </ul>"},{"location":"Explanation/why-deferred-commands-exist-in-an-archetype-ecs/#summary-the-why-in-one-sentence","title":"Summary: the \u201cwhy\u201d in one sentence","text":"<p>Deferred commands exist because archetype queries iterate dense tables, and structural changes move rows between tables, which can invalidate iteration\u2014so we queue structural changes and apply them at safe flush boundaries (<code>flush()</code> / schedule phases). </p>"},{"location":"Explanation/why-use-Events-in-ECS/","title":"Why use Events in ECS?","text":""},{"location":"Explanation/why-use-Events-in-ECS/#events-solve-a-different-problem-than-components-and-resources","title":"Events solve a different problem than Components and Resources","text":"<p>ECS has three kinds of data:</p> <ul> <li>Components: persistent, per-entity state (Position, Velocity, Health)</li> <li>Resources: persistent, global state (Input, Time, Config, caches)</li> <li>Events: transient messages (Hit happened, Click happened, Play sound)</li> </ul> <p>Trying to represent \u201csomething happened\u201d as a component usually causes awkward designs:</p> <ul> <li>adding/removing \u201cEvent components\u201d becomes structural churn</li> <li>you need cleanup systems to remove them</li> <li>multiple systems race to observe/remove them</li> </ul> <p>Events avoid that by being explicitly transient.</p>"},{"location":"Explanation/why-use-Events-in-ECS/#events-reduce-coupling-between-systems","title":"Events reduce coupling between systems","text":"<p>Without events:</p> <ul> <li><code>combatSystem</code> might call <code>audioSystem</code> directly</li> <li>or it might mutate a shared global array</li> </ul> <p>With events:</p> <ul> <li>producers don\u2019t know consumers exist</li> <li>consumers don\u2019t know who produced the messages</li> </ul> <p>This keeps systems reusable and easy to rearrange in <code>Schedule</code>.</p>"},{"location":"Explanation/why-use-Events-in-ECS/#why-double-buffering","title":"Why double-buffering?","text":"<p>A common bug in event systems is \u201cevents appear while I\u2019m iterating\u201d.</p> <p>Double-buffering prevents that:</p> <ul> <li>consumers read a stable snapshot (<code>read buffer</code>)</li> <li>producers write to a different buffer (<code>write buffer</code>)</li> <li>swap happens at deterministic boundaries</li> </ul> <p>No surprises. No iterator invalidation. No mid-phase visibility.</p>"},{"location":"Explanation/why-use-Events-in-ECS/#why-phase-scoped-delivery","title":"Why phase-scoped delivery?","text":"<p>This ECS already has a concept of phase boundaries:</p> <ul> <li>structural changes are deferred via Commands</li> <li><code>flush()</code> applies them between phases</li> </ul> <p>Events align with the same boundary:</p> <ul> <li><code>swapEvents()</code> delivers events between phases</li> </ul> <p>This makes it easy to design pipelines:</p> <ul> <li><code>input</code> produces actions \u2192 <code>beforeUpdate</code> consumes</li> <li><code>update</code> produces gameplay events \u2192 <code>afterUpdate</code> consumes</li> <li><code>render</code> produces UI/VFX events \u2192 <code>afterRender</code> consumes</li> <li><code>audio</code> consumes sound events</li> </ul>"},{"location":"Explanation/why-use-Events-in-ECS/#trade-offs-and-the-forwarding-pattern","title":"Trade-offs (and the forwarding pattern)","text":"<p>With phase-scoped delivery, an event is visible in the next phase only. To deliver an event across multiple phases (e.g., from <code>update</code> to <code>audio</code>), you forward it by draining and re-emitting.</p> <p>This is deliberate:</p> <ul> <li>it keeps pipelines explicit</li> <li>prevents \u201cstale\u201d events lingering through unrelated phases</li> <li>makes delivery deterministic and easy to debug</li> </ul>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/","title":"How to add InputState + AssetCache as Resources and use them in systems","text":""},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#goal","title":"Goal","text":"<p>Store Input state and an Asset cache as world Resources, then access them inside systems using <code>requireResource()</code>.</p>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#example-inputstateres","title":"Example InputStateRes","text":"<pre><code>export class InputStateRes\n{\n    public keysDown = new Set&lt;string&gt;();\n    public keysPressed = new Set&lt;string&gt;();   // pressed this frame\n    public keysReleased = new Set&lt;string&gt;();  // released this frame\n\n    public mouseX = 0;\n    public mouseY = 0;\n    public mouseButtonsDown = new Set&lt;number&gt;();\n    public mousePressed = new Set&lt;number&gt;();   // pressed this frame\n    public mouseReleased = new Set&lt;number&gt;();  // released this frame\n    public wheelDeltaY = 0;\n\n    beginFrame(): void\n    {\n        this.keysPressed.clear();\n        this.keysReleased.clear();\n        this.mousePressed.clear();\n        this.mouseReleased.clear();\n        this.wheelDeltaY = 0;\n    }\n\n    keyDown(code: string): void\n    {\n        if (!this.keysDown.has(code)) this.keysPressed.add(code);\n        this.keysDown.add(code);\n    }\n\n    keyUp(code: string): void\n    {\n        if (this.keysDown.has(code)) this.keysReleased.add(code);\n        this.keysDown.delete(code);\n    }\n\n    mouseMove(x: number, y: number): void {\n        this.mouseX = x;\n        this.mouseY = y;\n    }\n\n    mouseDown(btn: number): void\n    {\n        if (!this.mouseButtonsDown.has(btn)) this.mousePressed.add(btn);\n        this.mouseButtonsDown.add(btn);\n    }\n\n    mouseUp(btn: number): void\n    {\n        if (this.mouseButtonsDown.has(btn)) this.mouseReleased.add(btn);\n        this.mouseButtonsDown.delete(btn);\n    }\n\n    wheel(deltaY: number): void\n    {\n        this.wheelDeltaY += deltaY;\n    }\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#example-assetcacheres","title":"Example AssetCacheRes","text":"<pre><code>export class AssetCacheRes\n{\n    private images = new Map&lt;string, HTMLImageElement&gt;();\n    private pending = new Map&lt;string, Promise&lt;HTMLImageElement&gt;&gt;();\n\n    /** Loads once, dedupes concurrent calls, returns the same instance thereafter. */\n    public getImage(url: string): Promise&lt;HTMLImageElement&gt;\n    {\n        const ready = this.images.get(url);\n        if (ready) return Promise.resolve(ready);\n\n        const p = this.pending.get(url);\n        if (p) return p;\n\n        const promise = new Promise&lt;HTMLImageElement&gt;((resolve, reject) =&gt; {\n            const img = new Image();\n            img.onload = () =&gt; {\n                this.images.set(url, img);\n                this.pending.delete(url);\n                resolve(img);\n            };\n            img.onerror = (e) =&gt; {\n                this.pending.delete(url);\n                reject(e);\n            };\n            img.src = url;\n        });\n\n        this.pending.set(url, promise);\n        return promise;\n    }\n\n    /** Returns the image if already loaded; otherwise undefined. */\n    public peekImage(url: string): HTMLImageElement | undefined {\n        return this.images.get(url);\n    }\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#1-register-the-resources-at-startup","title":"1) Register the resources at startup","text":"<pre><code>world.initResource(InputStateRes, () =&gt; new InputStateRes());\nworld.initResource(AssetCacheRes, () =&gt; new AssetCacheRes());\n</code></pre> <p>That\u2019s the only \u201crequired\u201d setup. Everything else assumes these exist.</p>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#2-wire-dom-events-into-inputstateres","title":"2) Wire DOM events into <code>InputStateRes</code>","text":"<p>Attach listeners once:</p> <pre><code>export function attachInput(world: WorldApi): void\n{\n    const input = world.requireResource(InputStateRes);\n\n    window.addEventListener(\"keydown\", e =&gt; input.keyDown(e.code));\n    window.addEventListener(\"keyup\",   e =&gt; input.keyUp(e.code));\n    window.addEventListener(\"mousemove\", e =&gt; input.mouseMove(e.clientX, e.clientY));\n    window.addEventListener(\"mousedown\", e =&gt; input.mouseDown(e.button));\n    window.addEventListener(\"mouseup\",   e =&gt; input.mouseUp(e.button));\n    window.addEventListener(\"wheel\",     e =&gt; input.wheel(e.deltaY), { passive: true });\n}\n</code></pre> <p>Call it after <code>initResource(...)</code>.</p>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#3-reset-pressedreleased-flags-once-per-frame","title":"3) Reset \u201cpressed/released\u201d flags once per frame","text":"<p>Add a phase/system that runs before gameplay update:</p> <pre><code>export function beginFrameSystem(w: WorldApi, _dt: number): void\n{\n    w.requireResource(InputStateRes).beginFrame();\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#4-read-input-from-systems","title":"4) Read input from systems","text":"<p>Example \u201cmove player\u201d system:</p> <pre><code>export function playerMoveSystem(w: WorldApi, dt: number): void\n{\n    const input = w.requireResource(InputStateRes);\n\n    let dx = 0, dy = 0;\n    if (input.keysDown.has(\"KeyW\")) dy -= 1;\n    if (input.keysDown.has(\"KeyS\")) dy += 1;\n    if (input.keysDown.has(\"KeyA\")) dx -= 1;\n    if (input.keysDown.has(\"KeyD\")) dx += 1;\n\n    const speed = 220;\n\n    for (const { c1: tr } of w.query(Transform, PlayerTag)) {\n        tr.x += dx * speed * dt;\n        tr.y += dy * speed * dt;\n    }\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#5-use-assetcacheres-in-a-render-system-deduped-async-loads","title":"5) Use <code>AssetCacheRes</code> in a render system (deduped async loads)","text":"<pre><code>export function renderSpritesSystem(ctx: CanvasRenderingContext2D)\n{\n    return (w: WorldApi, _dt: number): void =&gt; {\n        const assets = w.requireResource(AssetCacheRes);\n\n        for (const { c1: tr, c2: sp } of w.query(Transform, Sprite)) {\n            assets.getImage(sp.url).catch(() =&gt; {});\n            const img = assets.peekImage(sp.url);\n            if (!img) continue;\n\n            ctx.drawImage(img, tr.x, tr.y, sp.w, sp.h);\n        }\n    };\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#6-run-phases-in-order","title":"6) Run phases in order","text":"<p>Minimal schedule:</p> <pre><code>sched.add(\"beginFrame\", beginFrameSystem);\nsched.add(\"update\", playerMoveSystem);\nsched.add(\"render\", renderSpritesSystem(ctx));\n</code></pre> <p>Game loop:</p> <pre><code>sched.run(world, dt, [\"beginFrame\", \"update\", \"render\"]);\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#common-variations","title":"Common variations","text":""},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#optional-resource-usage","title":"Optional resource usage","text":"<p>If a resource is optional (debug/editor), use:</p> <pre><code>const dbg = w.getResource(DebugRes);\nif (dbg) dbg.enabled = true;\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-InputState-%2B-AssetCache-as-Resources-and-use-them-in-systems/#preload-assets-menuloading-screen","title":"Preload assets (menu/loading screen)","text":"<pre><code>await Promise.all(urls.map(u =&gt; world.requireResource(AssetCacheRes).getImage(u)));\n</code></pre>"},{"location":"How-To%20Guides/How-to-add-remove-components-at-runtime/","title":"How to add/remove components at runtime","text":"<ol> <li>Define your component types (classes):</li> </ol> <pre><code>class Position { constructor(public x = 0, public y = 0) {} }\nclass Velocity { constructor(public x = 0, public y = 0) {} }\n</code></pre> <ol> <li>Add/remove immediately when you are not iterating a query:</li> </ol> <pre><code>const e = world.spawn();\nworld.add(e, Position, new Position(0, 0));\nworld.add(e, Velocity, new Velocity(1, 0));\n\n// Or add many at once\nconst z = world.spawn();\nworld.addMany(z, [new Position(0, 0), new Velocity(1, 0)])\n\nworld.remove(e, Velocity);\n</code></pre> <ol> <li>Add/remove during a query/system using deferred commands:</li> </ol> <pre><code>world.addSystem((w: any) =&gt; {\n  for (const { e, c1: pos } of w.query(Position)) {\n    if (pos.x &gt; 10) w.cmd().add(e, Velocity, new Velocity(1, 0));\n    if (pos.x &lt; 0)  w.cmd().remove(e, Velocity);\n  }\n});\n\n// Or remove many at once\nworld.addSystem((w: any) =&gt; {\n  for (const { e, c1: pos } of w.query(Position, Velocity)) {\n    if (pos.x &lt; 0)  w.cmd().removeMny(e, Position, Velocity);\n  }\n});\n\n// apply queued structural changes\nworld.flush();\n</code></pre>"},{"location":"How-To%20Guides/How-to-despawn-entities-safely/","title":"How to despawn entities safely","text":"<ol> <li>Despawn immediately when not iterating:</li> </ol> <pre><code>world.despawn(e);\n</code></pre> <ol> <li>Despawn during a query/system via <code>cmd()</code>:</li> </ol> <pre><code>world.addSystem((w: any) =&gt; {\n  for (const { e, c1: pos } of w.query(Position)) {\n    if (pos.x &gt; 10) w.cmd().despawn(e);\n  }\n});\n\n// apply despawns\nworld.flush();\n</code></pre> <ol> <li>Or rely on end-of-frame flush:</li> </ol> <pre><code>world.update(dt); // runs systems, then flushes\n</code></pre>"},{"location":"How-To%20Guides/How-to-have-multiple-Worlds/","title":"How to have multiple Worlds (globe vs ground simulation)","text":"<ol> <li>Create two worlds:</li> </ol> <pre><code>const globeWorld = new World();\nconst groundWorld = new World();\n</code></pre> <ol> <li>Give each one its own schedule (recommended):</li> </ol> <pre><code>const globeSched  = new Schedule();\nconst groundSched = new Schedule();\n</code></pre> <ol> <li>Run both each frame (same <code>dt</code>):</li> </ol> <pre><code>globeSched.run(globeWorld, dt, [\"input\", \"sim\", \"render\"]);\ngroundSched.run(groundWorld, dt, [\"input\", \"sim\", \"render\"]);\n</code></pre> <ol> <li> <p>Share data explicitly between worlds (pick one):</p> </li> <li> <p>copy values at a known point (end of <code>sim</code>, start of other <code>sim</code>)</p> </li> <li>or have a \u201cbridge\u201d step in your outer loop that reads from one world and writes into the other (via normal <code>add/set</code> or via <code>cmd()</code> + <code>flush()</code>)</li> </ol>"},{"location":"How-To%20Guides/How-to-integrate-ECS-into-a-game-loop/","title":"How to integrate ECS into a game loop","text":""},{"location":"How-To%20Guides/How-to-integrate-ECS-into-a-game-loop/#option-a-use-worldupdatedt","title":"Option A \u2014 Use <code>world.update(dt)</code>","text":"<ol> <li>Register systems with <code>addSystem(...)</code></li> <li>In your loop call:</li> </ol> <pre><code>function tick(dt: number) {\n  world.update(dt); // runs systems, then flushes\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-integrate-ECS-into-a-game-loop/#option-b-use-schedule-phases-recommended-for-games","title":"Option B \u2014 Use <code>Schedule</code> phases (recommended for games)","text":"<ol> <li>Build a schedule (<code>input</code>, <code>sim</code>, <code>render</code>)</li> <li>In <code>requestAnimationFrame</code>:</li> </ol> <pre><code>let last = performance.now();\n\nfunction frame(now: number) {\n  const dt = (now - last) / 1000;\n  last = now;\n\n  sched.run(world, dt, [\"input\", \"sim\", \"render\"]); // flush between phases\n  renderer.render(scene, camera);\n\n  requestAnimationFrame(frame);\n}\n\nrequestAnimationFrame(frame);\n</code></pre>"},{"location":"How-To%20Guides/How-to-run-logic-conditionally/","title":"How to run logic conditionally","text":""},{"location":"How-To%20Guides/How-to-run-logic-conditionally/#option-a-guard-inside-the-system-simple","title":"Option A \u2014 Guard inside the system (simple)","text":"<ol> <li>Put a condition at the top:</li> </ol> <pre><code>let paused = false;\n\nworld.addSystem((w: any, dt: number) =&gt; {\n  if (paused) return;\n  for (const { c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x * dt;\n  }\n});\n</code></pre>"},{"location":"How-To%20Guides/How-to-run-logic-conditionally/#option-b-conditional-phases-skip-whole-groups","title":"Option B \u2014 Conditional phases (skip whole groups)","text":"<ol> <li>Maintain your phase list dynamically:</li> </ol> <pre><code>const base = [\"input\", \"sim\", \"render\"];\n\nfunction getPhases(paused: boolean) {\n  return paused ? [\"input\", \"render\"] : base;\n}\n\nsched.run(world, dt, getPhases(paused));\n</code></pre>"},{"location":"How-To%20Guides/How-to-run-logic-conditionally/#option-c-wrap-systems-reuse-predicates","title":"Option C \u2014 Wrap systems (reuse predicates)","text":"<ol> <li>Make a helper:</li> </ol> <pre><code>const runIf = (pred: () =&gt; boolean, fn: (w: any, dt: number) =&gt; void) =&gt;\n  (w: any, dt: number) =&gt; { if (pred()) fn(w, dt); };\n\nworld.addSystem(runIf(() =&gt; !paused, (w, dt) =&gt; {\n  for (const { c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x * dt;\n  }\n}));\n</code></pre>"},{"location":"How-To%20Guides/How-to-split-logic-into-multiple-system-phases/","title":"How to split logic into multiple system phases","text":"<ol> <li>Create a <code>Schedule</code> and register systems by phase name:</li> </ol> <pre><code>const sched = new Schedule();\n\nsched\n  .add(\"input\", (w: any) =&gt; { /* ... */ })\n  .add(\"sim\",   (w: any, dt: number) =&gt; { /* ... */ })\n  .add(\"render\",(w: any) =&gt; { /* ... */ });\n</code></pre> <ol> <li>Define phase order:</li> </ol> <pre><code>const phases = [\"input\", \"sim\", \"render\"];\n</code></pre> <ol> <li>Run it each tick (flush happens after each phase):</li> </ol> <pre><code>sched.run(world, dt, phases);\n</code></pre>"},{"location":"How-To%20Guides/How-to-use-ECS-alongside-Three.js/","title":"How to use ECS alongside Three.js","text":""},{"location":"How-To%20Guides/How-to-use-ECS-alongside-Three.js/#pattern-ecs-owns-state-threejs-owns-objects","title":"Pattern: ECS owns state, Three.js owns objects","text":"<ol> <li>Keep Three.js objects in a map (outside ECS):</li> </ol> <pre><code>const meshes = new Map&lt;number, THREE.Object3D&gt;(); // key = entity.id\n</code></pre> <ol> <li>Add components for simulation and \u201crender tag\u201d:</li> </ol> <pre><code>class Position { constructor(public x=0, public y=0, public z=0) {} }\nclass Renderable { constructor(public kind: \"cube\" | \"ship\" = \"cube\") {} }\n</code></pre> <ol> <li>Spawn entities in ECS:</li> </ol> <pre><code>const e = world.spawnMany(\n  new Position(0, 0, 0),\n  new Renderable(\"cube\")\n)\n</code></pre> <ol> <li> <p>Create a render-sync system in a <code>render</code> phase:</p> </li> <li> <p>create missing meshes</p> </li> <li>update transforms</li> <li>remove meshes for despawned entities (see step 5)</li> </ol> <pre><code>sched.add(\"render\", (w: any) =&gt; {\n  for (const { e, c1: pos, c2: rend } of w.query(Position, Renderable)) {\n    let obj = meshes.get(e.id);\n    if (!obj) {\n      obj = makeObjectFromKind(rend.kind); // your factory\n      scene.add(obj);\n      meshes.set(e.id, obj);\n    }\n    obj.position.set(pos.x, pos.y, pos.z);\n  }\n});\n</code></pre> <ol> <li> <p>Despawn visually after flush:</p> </li> <li> <p>despawn in ECS via <code>cmd().despawn(e)</code></p> </li> <li>after the flush boundary, remove from <code>meshes</code> if it\u2019s gone</li> </ol> <p>A simple cleanup pass each frame:</p> <pre><code>for (const [id, obj] of meshes) {\n  // if you track alive entities externally, remove when not alive anymore.\n  // (One common approach: record seen IDs during the render query and remove the rest.)\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/","title":"How to use Events to decouple systems across phases","text":""},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/#goal","title":"Goal","text":"<p>Emit events in one phase and consume them in a later phase, without coupling systems directly.</p> <p>This guide assumes you already have a <code>Schedule</code> with multiple phases and that the schedule swaps events between phases.</p>"},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/#1-define-event-types","title":"1) Define event types","text":"<p>Use classes (recommended) or token keys.</p> <pre><code>export class DamageEvent {\n    constructor(public target: Entity, public amount: number) {}\n}\n\nexport class PlaySoundEvent {\n    constructor(public id: string) {}\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/#2-emit-events-from-a-producer-system","title":"2) Emit events from a producer system","text":"<p>Example: gameplay system emits damage + sound.</p> <pre><code>function combatSystem(w: WorldApi, _dt: number) {\n    // ... detect hit\n    w.emit(DamageEvent, new DamageEvent(target, 10));\n    w.emit(PlaySoundEvent, new PlaySoundEvent(\"hit\"));\n}\n</code></pre>"},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/#3-consume-events-in-the-next-phase","title":"3) Consume events in the next phase","text":"<p>Place a consumer in the next phase (phase-scoped delivery):</p> <pre><code>function applyDamageSystem(w: WorldApi, _dt: number) {\n    w.drainEvents(DamageEvent, (ev) =&gt; {\n        const hp = w.get(ev.target, Health);\n        if (!hp) return;\n        hp.value -= ev.amount;\n    });\n}\n</code></pre> <p>Schedule order:</p> <pre><code>schedule.add(\"update\", combatSystem);\nschedule.add(\"afterUpdate\", applyDamageSystem);\n</code></pre>"},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/#4-deliver-events-to-late-phases-forwarding-pattern","title":"4) Deliver events to late phases (forwarding pattern)","text":"<p>With phase-scoped delivery, an event emitted in <code>update</code> is visible in <code>afterUpdate</code>. If you want it to reach <code>audio</code> several phases later, forward it:</p> <pre><code>function forwardSoundSystem(w: WorldApi, _dt: number) {\n    w.drainEvents(PlaySoundEvent, (ev) =&gt; {\n        w.emit(PlaySoundEvent, ev); // re-emit for the next phase\n    });\n}\n\nfunction audioSystem(w: WorldApi, _dt: number) {\n    w.drainEvents(PlaySoundEvent, (ev) =&gt; {\n        console.log(\"[audio] play:\", ev.id);\n    });\n}\n</code></pre> <p>Example pipeline:</p> <pre><code>schedule.add(\"update\", combatSystem);            // emits PlaySoundEvent\nschedule.add(\"afterUpdate\", forwardSoundSystem); // forwards -&gt; render\nschedule.add(\"afterRender\", forwardSoundSystem); // forwards -&gt; audio\nschedule.add(\"audio\", audioSystem);              // consumes\n</code></pre>"},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/#5-use-eventskeyvalues-for-read-only-inspection","title":"5) Use <code>events(key).values()</code> for read-only inspection","text":"<p>If you need to check what\u2019s readable without consuming it:</p> <pre><code>const pending = w.events(DamageEvent).values();\nif (pending.length &gt; 0) {\n    // inspect (do not store array reference)\n}\n</code></pre> <p>Prefer <code>drainEvents</code> for typical processing.</p>"},{"location":"How-To%20Guides/How-to-use-Events-to-decouple-systems-across-phases/#6-clear-events-when-resetting-state","title":"6) Clear events when resetting state","text":"<p>To clear one type:</p> <pre><code>w.clearEvents(DamageEvent);\n</code></pre> <p>To clear all readable event buffers:</p> <pre><code>w.clearEvents();\n</code></pre>"},{"location":"Reference/archetypes/","title":"Archetypes","text":""},{"location":"Reference/archetypes/#purpose","title":"Purpose","text":"<p>An archetype is an internal storage \u201ctable\u201d that groups together all entities sharing the same set of component types. Archetypes are the core performance mechanism of this ECS: queries match archetypes first, then iterate rows inside them. </p>"},{"location":"Reference/archetypes/#storage-model","title":"Storage model","text":""},{"location":"Reference/archetypes/#table-layout-soa","title":"Table layout (SoA)","text":"<p>Archetypes store component data in Structure of Arrays (SoA) form:</p> <ul> <li>one column per component type</li> <li>each entity occupies a row across all columns </li> </ul> <p>This is the reason queries are efficient: iteration is over dense arrays rather than scattered objects. </p>"},{"location":"Reference/archetypes/#archetype-membership","title":"Archetype membership","text":""},{"location":"Reference/archetypes/#structural-changes-move-entities-between-archetypes","title":"Structural changes move entities between archetypes","text":"<p>When an entity\u2019s component set changes, the entity moves to a different archetype:</p> <ul> <li><code>add(e, Ctor, value)</code> is structural and may move the entity to another archetype </li> <li><code>remove(e, Ctor)</code> is structural and may move the entity to another archetype </li> </ul> <p>Non-structural updates do not change archetype membership:</p> <ul> <li><code>set(e, Ctor, value)</code> updates the value but does not change the component set </li> </ul>"},{"location":"Reference/archetypes/#queries-and-archetypes","title":"Queries and archetypes","text":""},{"location":"Reference/archetypes/#archetype-filtering","title":"Archetype filtering","text":"<p><code>query(...ctors)</code> only iterates archetypes that contain all required component columns, then yields matching entity rows. </p>"},{"location":"Reference/archetypes/#query-row-shape","title":"Query row shape","text":"<p>For <code>query(A, B, C)</code>, the yielded row contains:</p> <ul> <li><code>e</code> (entity handle)</li> <li><code>c1</code>, <code>c2</code>, <code>c3</code> component values in the same order as the ctor arguments </li> </ul>"},{"location":"Reference/archetypes/#safety-constraints","title":"Safety constraints","text":""},{"location":"Reference/archetypes/#structural-changes-during-iteration","title":"Structural changes during iteration","text":"<p>While iterating queries (and generally while systems run), doing structural changes directly can throw. The recommended pattern is:</p> <ul> <li>enqueue structural changes via <code>world.cmd()</code></li> <li>apply them via <code>world.flush()</code> (or at the end of <code>world.update(dt)</code>) </li> </ul> <p>This matters because structural changes imply archetype moves. </p>"},{"location":"Reference/archetypes/#visibility-public-api","title":"Visibility / Public API","text":"<p>Archetypes are an internal mechanism (the public exports are <code>Types</code>, <code>TypeRegistry</code>, <code>Commands</code>, <code>World</code>, <code>Schedule</code>). Users interact with archetypes only indirectly through <code>World</code> operations and <code>query()</code>. </p>"},{"location":"Reference/commands/","title":"Commands","text":""},{"location":"Reference/commands/#purpose","title":"Purpose","text":"<p><code>Commands</code> is a deferred structural change buffer. It lets you enqueue structural operations (spawn/despawn/add/remove) while iterating queries or running systems, then apply them later via <code>world.flush()</code> (or at the end of <code>world.update(dt)</code>). </p>"},{"location":"Reference/commands/#how-to-obtain-a-commands-buffer","title":"How to obtain a <code>Commands</code> buffer","text":""},{"location":"Reference/commands/#worldcmd-commands","title":"<code>world.cmd(): Commands</code>","text":"<p><code>World.cmd()</code> returns a <code>Commands</code> instance you can use to enqueue operations. </p> <p>Typical usage: </p> <pre><code>const cmd = world.cmd();\n\ncmd.spawn((e) =&gt; {\n    cmd.add(e, Position, new Position(0, 0));\n});\n\ncmd.add(entity, Velocity, new Velocity(1, 0));\ncmd.remove(entity, Velocity);\ncmd.despawn(entity);\n\nworld.flush();\n</code></pre>"},{"location":"Reference/commands/#supported-operations","title":"Supported operations","text":"<p>The command buffer supports these operations (as documented by the project): </p>"},{"location":"Reference/commands/#spawninit","title":"<code>spawn(init?)</code>","text":"<p>Enqueues creation of a new entity.</p> <ul> <li><code>init?: (e: Entity) =&gt; void</code> is an optional callback invoked with the spawned entity, typically used to enqueue <code>add()</code> calls for initial components. </li> </ul>"},{"location":"Reference/commands/#spawnbundleitems-componentctorbundleitem","title":"<code>spawnBundle(...items: ComponentCtorBundleItem[])</code>","text":"<p>Queues the creation of a new entity, along with its initial components, and applies everything on the next flush (within the same flush cycle).</p> <ul> <li><code>...items: ComponentCtorBundleItem[]</code> is the list of components to add to the newly created entity.</li> <li>Internally, it iterates over the items and calls <code>add(e, ctor, value)</code> for each component.</li> </ul>"},{"location":"Reference/commands/#despawne-entity","title":"<code>despawn(e: Entity)</code>","text":"<p>Enqueues removal of an entity. </p>"},{"location":"Reference/commands/#despawnbundleentities-entity","title":"<code>despawnBundle(entities: Entity[])</code>","text":"<p>Enqueues the destruction of multiple entities. The actual removals are applied when commands are flushed.</p> <ul> <li><code>entities: Entity[]</code> is the list of entities to despawn.</li> <li>Internally, it iterates over the array and calls <code>despawn(e)</code> for each entity.</li> </ul>"},{"location":"Reference/commands/#adde-ctor-value","title":"<code>add(e, ctor, value)</code>","text":"<p>Enqueues adding a component to an entity. This is a structural change (it may move the entity between archetypes), which is why it is commonly deferred. </p>"},{"location":"Reference/commands/#addbundlee-entity-items-componentctorbundleitem","title":"<code>addBundle(e: Entity, ...items: ComponentCtorBundleItem[])</code>","text":"<p>Enqueues adding multiple components to an existing entity. All component adds are applied on flush.</p> <ul> <li><code>e: Entity</code> is the target entity.</li> <li><code>...items: ComponentCtorBundleItem[]</code> is the list of components to add.</li> <li>Internally, it loops through the items and calls <code>add(e, ctor, value)</code> for each component.</li> </ul>"},{"location":"Reference/commands/#removee-ctor","title":"<code>remove(e, ctor)</code>","text":"<p>Enqueues removing a component from an entity. This is also a structural change. </p>"},{"location":"Reference/commands/#removebundlee-entity-ctors-componentctorany","title":"<code>removeBundle(e: Entity, ...ctors: ComponentCtor&lt;any&gt;[])</code>","text":"<p>Enqueues removal of multiple component types from an entity. The removals are applied on flush.</p> <ul> <li><code>e: Entity</code> is the target entity.</li> <li><code>...ctors: ComponentCtor&lt;any&gt;[]</code> is the list of component constructors (types) to remove.</li> <li>Internally, it loops through the ctors and calls <code>remove(e, ctor)</code> for each one.</li> </ul>"},{"location":"Reference/commands/#applying-commands","title":"Applying commands","text":""},{"location":"Reference/commands/#worldflush-void","title":"<code>world.flush(): void</code>","text":"<p>Applies all queued commands. <code>World.update(dt)</code> also flushes automatically at the end of the frame. </p>"},{"location":"Reference/commands/#with-schedule","title":"With <code>Schedule</code>","text":"<p>When using <code>Schedule</code>, <code>world.flush()</code> is called after each phase, creating deterministic \u201cphase barriers\u201d for command application. </p>"},{"location":"Reference/commands/#safety-rule","title":"Safety rule","text":"<p>Direct structural operations can throw while iterating queries or running systems. The intended pattern is:</p> <ul> <li>enqueue structural changes with <code>world.cmd()</code></li> <li>apply them with <code>world.flush()</code> (or let <code>update()</code> do it) </li> </ul>"},{"location":"Reference/components/","title":"Components","text":""},{"location":"Reference/components/#purpose","title":"Purpose","text":"<p>A component is a unit of data attached to an <code>Entity</code>. In this ECS, components are stored in archetypes (tables) using a Structure-of-Arrays (SoA) layout: one column per component type. </p>"},{"location":"Reference/components/#component-type-key","title":"Component \u201ctype\u201d (key)","text":"<p>A component type is identified by a constructor (typically a class):</p> <pre><code>class Position { constructor(public x = 0, public y = 0) {} }\nclass Velocity { constructor(public x = 0, public y = 0) {} }\n</code></pre> <p>Any class used as a type key is considered a valid component type. </p>"},{"location":"Reference/components/#typeid-mapping","title":"TypeId mapping","text":"<p>Internally, component constructors are mapped to a stable numeric <code>TypeId</code> via <code>typeId()</code>.  <code>TypeId</code> assignment is process-local and based on constructor identity (via <code>WeakMap</code>). </p>"},{"location":"Reference/components/#component-value","title":"Component \u201cvalue\u201d","text":"<p>The component value is the actual instance stored in the archetype column (e.g. <code>new Position(1,2)</code>).</p> <ul> <li>Values are stored per-archetype, per-column (SoA) </li> <li>Queries return direct references to these values (you mutate them in place)</li> </ul>"},{"location":"Reference/components/#world-operations-on-components","title":"World operations on components","text":"<p>All component operations are done through <code>World</code> using the component constructor as the key. </p>"},{"location":"Reference/components/#presence-access","title":"Presence / access","text":"<ul> <li><code>has(e, Ctor): boolean</code> </li> <li><code>get(e, Ctor): T | undefined</code> </li> </ul>"},{"location":"Reference/components/#update-non-structural","title":"Update (non-structural)","text":"<ul> <li><code>set(e, Ctor, value): void</code>   Requires the component to exist; otherwise throws. </li> </ul>"},{"location":"Reference/components/#structural-changes","title":"Structural changes","text":"<p>These may move the entity between archetypes:</p> <ul> <li><code>add(e, Ctor, value): void</code> </li> <li><code>remove(e, Ctor): void</code> </li> </ul>"},{"location":"Reference/components/#queries-and-component-ordering","title":"Queries and component ordering","text":"<p><code>world.query(A, B, C)</code> yields rows shaped like:</p> <ul> <li><code>e</code>: the entity</li> <li><code>c1</code>, <code>c2</code>, <code>c3</code>: component values in the same order as the ctor arguments </li> </ul> <p>Example:</p> <pre><code>for (const { e, c1: pos, c2: vel } of world.query(Position, Velocity)) { }\n</code></pre>"},{"location":"Reference/components/#safety-rules-during-iteration","title":"Safety rules during iteration","text":"<p>While iterating a query (or while systems are running), direct structural changes can throw. Use deferred commands instead:</p> <ul> <li>enqueue via <code>world.cmd()</code></li> <li>apply via <code>world.flush()</code> </li> </ul>"},{"location":"Reference/entity/","title":"Entity","text":""},{"location":"Reference/entity/#purpose","title":"Purpose","text":"<p>An Entity is a lightweight, opaque handle used to reference rows stored inside archetypes. It is not the data itself (components hold the data). </p>"},{"location":"Reference/entity/#type","title":"Type","text":"<pre><code>type Entity = { id: number; gen: number };\n</code></pre> <ul> <li><code>id</code>: stable numeric slot identifier</li> <li><code>gen</code>: generation counter used to detect stale handles after despawn / reuse </li> </ul>"},{"location":"Reference/entity/#semantics","title":"Semantics","text":""},{"location":"Reference/entity/#identity","title":"Identity","text":"<p>An entity handle is considered valid only if both:</p> <ul> <li>the <code>id</code> refers to an allocated slot</li> <li>the <code>gen</code> matches the current generation for that slot </li> </ul>"},{"location":"Reference/entity/#stale-handles","title":"Stale handles","text":"<p>If an entity is despawned and the <code>id</code> is later reused, the <code>gen</code> will differ. This prevents accidentally operating on \u201cthe new entity that reused the same id\u201d. </p>"},{"location":"Reference/entity/#where-entities-come-from","title":"Where entities come from","text":"<ul> <li><code>world.spawn()</code> returns an <code>Entity</code> handle </li> <li><code>world.query(...)</code> yields rows that include <code>e: Entity</code> </li> </ul>"},{"location":"Reference/entity/#where-entities-are-used","title":"Where entities are used","text":"<p>Entities are passed into World operations (examples):</p> <ul> <li>lifecycle: <code>despawn(e)</code></li> <li>components: <code>add(e, Ctor, value)</code>, <code>remove(e, Ctor)</code>, <code>get(e, Ctor)</code>, <code>set(e, Ctor, value)</code> </li> <li>commands (deferred): <code>cmd.despawn(e)</code>, <code>cmd.add(e, ...)</code>, <code>cmd.remove(e, ...)</code> </li> </ul>"},{"location":"Reference/entity/#related-behavior","title":"Related behavior","text":""},{"location":"Reference/entity/#safety-during-iteration","title":"Safety during iteration","text":"<p>When iterating query results (which contain <code>e: Entity</code>), structural changes should be deferred via commands and applied with <code>flush()</code>. </p>"},{"location":"Reference/events/","title":"Reference: Events API","text":""},{"location":"Reference/events/#overview","title":"Overview","text":"<p>Events are typed, transient messages used to decouple systems. They are stored per event type in double-buffered channels:</p> <ul> <li><code>emit()</code> appends to the write buffer (current phase)</li> <li><code>drain()</code> / <code>values()</code> read from the read buffer (previous phase)</li> <li>At each phase boundary, <code>world.swapEvents()</code> swaps buffers so events become visible to the next phase</li> </ul>"},{"location":"Reference/events/#key-type","title":"Key type","text":"<p>Event channels are keyed by <code>ComponentCtor&lt;T&gt;</code> (same as components/resources). Keys are compared by identity.</p>"},{"location":"Reference/events/#eventchannelt-eventsts","title":"<code>EventChannel&lt;T&gt;</code> (Events.ts)","text":""},{"location":"Reference/events/#emitev-t-void","title":"<code>emit(ev: T): void</code>","text":"<p>Appends an event to the write buffer for the current phase.</p> <p>Notes</p> <ul> <li>Emitted events are not readable in the same phase</li> <li>They become readable after the next <code>swapBuffers()</code> / <code>world.swapEvents()</code></li> </ul>"},{"location":"Reference/events/#drainfn-ev-t-void-void","title":"<code>drain(fn: (ev: T) =&gt; void): void</code>","text":"<p>Iterates all readable events (read buffer) and then clears that buffer.</p> <p>Semantics</p> <ul> <li>Reads only events emitted in the previous phase</li> <li>After <code>drain</code>, <code>count()</code> becomes <code>0</code></li> </ul> <p>Performance</p> <ul> <li>No iterator allocations; uses indexed loop</li> <li>Clears with <code>length = 0</code></li> </ul>"},{"location":"Reference/events/#values-readonly-t","title":"<code>values(): readonly T[]</code>","text":"<p>Returns a read-only view of the read buffer.</p> <p>Semantics</p> <ul> <li>Snapshot is valid until the next boundary swap</li> <li>Do not store the returned array long-term</li> </ul>"},{"location":"Reference/events/#count-number","title":"<code>count(): number</code>","text":"<p>Returns the number of readable events currently in the read buffer.</p>"},{"location":"Reference/events/#clear-void","title":"<code>clear(): void</code>","text":"<p>Clears the read buffer only.</p>"},{"location":"Reference/events/#clearall-void","title":"<code>clearAll(): void</code>","text":"<p>Clears both read and write buffers.</p>"},{"location":"Reference/events/#swapbuffers-void-internal","title":"<code>swapBuffers(): void</code> (internal)","text":"<p>Swaps read/write buffers and clears the new write buffer.</p> <p>Semantics</p> <ul> <li>Makes events emitted in the previous phase readable now</li> <li>Drops any undrained events from the prior read buffer at the next swap (phase-scoped delivery)</li> </ul>"},{"location":"Reference/events/#delivery-model-summary-phase-scoped","title":"Delivery model summary (phase-scoped)","text":"<p>If you run phases:</p> <p><code>A -&gt; B -&gt; C</code></p> <p>Events emitted in A are readable in B. If not drained in B, they are dropped at <code>B -&gt; C</code> swap.</p>"},{"location":"Reference/queries/","title":"Query \u2014 Reference","text":""},{"location":"Reference/queries/#purpose","title":"Purpose","text":"<p>A Query iterates all entities that have all required component types, efficiently by scanning only the matching archetypes (tables). </p>"},{"location":"Reference/queries/#api","title":"API","text":""},{"location":"Reference/queries/#worldqueryctors-iterableany","title":"<code>world.query(...ctors): Iterable&lt;any&gt;</code>","text":"<p><code>ctors</code> is a list of component constructors (types) you want to require.</p> <pre><code>for (const row of world.query(Position, Velocity)) {\n  // ...\n}\n</code></pre> <p>Queries yield rows shaped like: </p> <ul> <li><code>e</code>: the <code>Entity</code></li> <li><code>c1</code>, <code>c2</code>, <code>c3</code>, \u2026: component values in the same order as the <code>ctors</code> arguments</li> </ul> <p>So <code>query(A, B, C)</code> yields <code>{ e, c1: A, c2: B, c3: C }</code>. </p>"},{"location":"Reference/queries/#row-mapping-and-ordering","title":"Row mapping and ordering","text":""},{"location":"Reference/queries/#deterministic-component-fields","title":"Deterministic component fields","text":"<p>The mapping is positional:</p> <ul> <li><code>query(A)</code> \u2192 <code>{ e, c1 }</code></li> <li><code>query(A, B)</code> \u2192 <code>{ e, c1, c2 }</code></li> <li><code>query(A, B, C)</code> \u2192 <code>{ e, c1, c2, c3 }</code></li> </ul> <p>And <code>cN</code> always corresponds to the Nth constructor you passed. </p>"},{"location":"Reference/queries/#safety-rules-during-iteration","title":"Safety rules during iteration","text":"<p>While iterating a query (or while systems are running), structural changes (spawn/despawn/add/remove) can throw.</p> <p>Use:</p> <ul> <li><code>world.cmd()</code> to defer changes</li> <li><code>world.flush()</code> (or <code>world.update()</code>) to apply them safely </li> </ul>"},{"location":"Reference/queries/#example","title":"Example","text":"<pre><code>for (const { e, c1: pos, c2: vel } of world.query(Position, Velocity)) {\n    pos.x += vel.x;\n    pos.y += vel.y;\n\n    // Safe structural change: defer it\n    if (pos.x &gt; 10) world.cmd().despawn(e);\n}\n</code></pre> <p>This pattern is recommended explicitly for queries. </p>"},{"location":"Reference/resources/","title":"Resources (Singletons / World Globals)","text":"<p>Resources are typed singleton values stored on the <code>World</code>, keyed by a <code>ComponentCtor&lt;T&gt;</code> (same \u201ckey shape\u201d as components). They are not attached to entities.</p> <p>They\u2019re ideal for global state like Time, Input, Asset caches, Config, RNG, Selection, etc.</p>"},{"location":"Reference/resources/#concepts","title":"Concepts","text":""},{"location":"Reference/resources/#what-is-a-resource","title":"What is a Resource?","text":"<p>A resource is a single instance of data stored globally in the ECS <code>World</code>.</p> <ul> <li>Components \u2192 many per world, attached to entities</li> <li>Resources \u2192 one per key, stored in the world</li> </ul>"},{"location":"Reference/resources/#key-type-componentctort","title":"Key type: <code>ComponentCtor&lt;T&gt;</code>","text":"<p>All resource APIs use:</p> <pre><code>ComponentCtor&lt;T&gt;\n</code></pre> <p>This usually means:</p> <ul> <li>a class constructor (e.g. <code>class TimeRes { ... }</code>)</li> <li>or a token function (unique function used as a key)</li> </ul> <p>Keys are compared by identity (reference equality), not by name.</p>"},{"location":"Reference/resources/#api-summary","title":"API summary","text":"<p>All methods live on <code>World</code> / <code>WorldApi</code>.</p> <pre><code>setResource&lt;T&gt;(key: ComponentCtor&lt;T&gt;, value: T): void\ngetResource&lt;T&gt;(key: ComponentCtor&lt;T&gt;): T | undefined\nrequireResource&lt;T&gt;(key: ComponentCtor&lt;T&gt;): T\nhasResource&lt;T&gt;(key: ComponentCtor&lt;T&gt;): boolean\nremoveResource&lt;T&gt;(key: ComponentCtor&lt;T&gt;): boolean\ninitResource&lt;T&gt;(key: ComponentCtor&lt;T&gt;, factory: () =&gt; T): T\n</code></pre> <p>Structural safety: resource operations are not structural changes (unlike spawn/despawn/add/remove). They do not require flushing and are safe to call during system execution.</p>"},{"location":"Reference/resources/#method-reference","title":"Method reference","text":""},{"location":"Reference/resources/#setresourcetkey-value-void","title":"<code>setResource&lt;T&gt;(key, value): void</code>","text":"<p>Stores (or replaces) the resource value for <code>key</code>.</p> <p>Behavior</p> <ul> <li>Overwrites any existing value.</li> <li>Does not flush and does not affect archetypes.</li> </ul> <p>Example</p> <pre><code>class ConfigRes { constructor(public difficulty: \"easy\" | \"hard\") {} }\n\nworld.setResource(ConfigRes, new ConfigRes(\"hard\"));\n</code></pre>"},{"location":"Reference/resources/#getresourcetkey-t-undefined","title":"<code>getResource&lt;T&gt;(key): T | undefined</code>","text":"<p>Returns the resource value if present, otherwise <code>undefined</code>.</p> <p>Use when</p> <ul> <li>the resource is optional (debug tools, plugins, editor-only state)</li> </ul> <p>Important note</p> <ul> <li>If you explicitly store <code>undefined</code> as the value, this also returns <code>undefined</code>.</li> <li> <p>Use <code>hasResource(key)</code> to distinguish:</p> </li> <li> <p>\u201cmissing\u201d</p> </li> <li>vs \u201cpresent but undefined\u201d</li> </ul> <p>Example</p> <pre><code>const debug = world.getResource(DebugRes);\nif (debug) debug.enabled = true;\n</code></pre>"},{"location":"Reference/resources/#requireresourcetkey-t","title":"<code>requireResource&lt;T&gt;(key): T</code>","text":"<p>Returns the resource value if present, otherwise throws.</p> <p>Use when</p> <ul> <li>the resource is required for correct operation (Time, Input, AssetCache, Config)</li> </ul> <p>Throws</p> <ul> <li><code>Error</code> if missing</li> </ul> <p>Example</p> <pre><code>const input = w.requireResource(InputStateRes);\nif (input.keysDown.has(\"KeyW\")) { /* ... */ }\n</code></pre>"},{"location":"Reference/resources/#hasresourcetkey-boolean","title":"<code>hasResource&lt;T&gt;(key): boolean</code>","text":"<p>Checks whether an entry exists for <code>key</code>.</p> <p>Use when</p> <ul> <li>you need to distinguish missing vs present-but-undefined</li> <li>you want conditional initialization</li> </ul> <p>Example</p> <pre><code>if (!world.hasResource(TimeRes)) {\n  world.setResource(TimeRes, new TimeRes());\n}\n</code></pre>"},{"location":"Reference/resources/#removeresourcetkey-boolean","title":"<code>removeResource&lt;T&gt;(key): boolean</code>","text":"<p>Removes the resource entry for <code>key</code>.</p> <p>Returns</p> <ul> <li><code>true</code> if the entry existed and was removed</li> <li><code>false</code> otherwise</li> </ul> <p>Example</p> <pre><code>world.removeResource(DebugRes);\n</code></pre>"},{"location":"Reference/resources/#initresourcetkey-factory-t","title":"<code>initResource&lt;T&gt;(key, factory): T</code>","text":"<p>Insert-once helper.</p> <p>Behavior</p> <ul> <li>If resource exists \u2192 returns existing value (factory is not called)</li> <li>If missing \u2192 calls <code>factory()</code>, stores, returns the new value</li> </ul> <p>Use when</p> <ul> <li>bootstrapping default resources without double-init</li> </ul> <p>Example</p> <pre><code>class TimeRes { dt = 0; elapsed = 0; }\n\nworld.initResource(TimeRes, () =&gt; new TimeRes());\n</code></pre>"},{"location":"Reference/resources/#usage-patterns","title":"Usage patterns","text":""},{"location":"Reference/resources/#pattern-bootstrap-required-resources-once","title":"Pattern: \u201cbootstrap required resources once\u201d","text":"<pre><code>class TimeRes { dt = 0; elapsed = 0; }\nclass InputStateRes { keysDown = new Set&lt;string&gt;(); }\n\nworld.initResource(TimeRes, () =&gt; new TimeRes());\nworld.initResource(InputStateRes, () =&gt; new InputStateRes());\n</code></pre>"},{"location":"Reference/resources/#pattern-systems-read-required-resources","title":"Pattern: \u201csystems read required resources\u201d","text":"<pre><code>function timeSystem(w: WorldApi, dt: number) {\n  const time = w.requireResource(TimeRes);\n  time.dt = dt;\n  time.elapsed += dt;\n}\n</code></pre>"},{"location":"Reference/resources/#pattern-asset-cache-resource","title":"Pattern: \u201casset cache resource\u201d","text":"<pre><code>class AssetCacheRes {\n  images = new Map&lt;string, HTMLImageElement&gt;();\n}\n\nworld.initResource(AssetCacheRes, () =&gt; new AssetCacheRes());\n</code></pre>"},{"location":"Reference/resources/#gotchas","title":"Gotchas","text":""},{"location":"Reference/resources/#1-keys-must-be-stable-and-unique","title":"1) Keys must be stable and unique","text":"<p>Because keys are identity-based:</p> <ul> <li>\u2705 <code>class TimeRes {}</code> used as key is stable</li> <li>\u2705 a top-level <code>const TOKEN = (() =&gt; {}) as ComponentCtor&lt;T&gt;</code> is stable</li> <li>\u274c creating a new token function inline each time won\u2019t match previous entries</li> </ul>"},{"location":"Reference/resources/#2-prefer-requireresource-in-gameplay-systems","title":"2) Prefer <code>requireResource()</code> in gameplay systems","text":"<p>It keeps systems clean and fails fast when initialization is missing.</p>"},{"location":"Reference/resources/#3-resources-are-not-entities","title":"3) Resources are not entities","text":"<p>Do not use resources for data that should exist per-entity (that\u2019s components).</p>"},{"location":"Reference/schedule/","title":"Schedule","text":""},{"location":"Reference/schedule/#purpose","title":"Purpose","text":"<p><code>Schedule</code> is a phase runner: it groups systems under named phases, then runs those phases in a chosen order, calling <code>world.flush()</code> between phases to apply deferred structural commands deterministically. </p>"},{"location":"Reference/schedule/#construction","title":"Construction","text":"<pre><code>const sched = new Schedule();\n</code></pre> <p><code>Schedule</code> is independent from <code>World</code>; you pass the <code>World</code> (or compatible object) at run time. </p>"},{"location":"Reference/schedule/#adding-systems-to-phases","title":"Adding systems to phases","text":""},{"location":"Reference/schedule/#addphase-string-fn-systemfn-this","title":"<code>add(phase: string, fn: SystemFn): this</code>","text":"<p>Registers a system function under a phase name.</p> <ul> <li>You can register multiple systems under the same phase. </li> </ul> <p>Example:</p> <pre><code>sched\n  .add(\"input\",  (w: any) =&gt; { /* ... */ })\n  .add(\"sim\",    (w: any, dt) =&gt; { /* ... */ })\n  .add(\"render\", (w: any) =&gt; { /* ... */ });\n</code></pre>"},{"location":"Reference/schedule/#running-phases","title":"Running phases","text":""},{"location":"Reference/schedule/#runworld-worldlike-dt-number-phases-string-void","title":"<code>run(world: WorldLike, dt: number, phases: string[]): void</code>","text":"<p>Runs the schedule for a single tick:</p> <ul> <li>Executes phases in the exact order provided by <code>phases</code>.</li> <li>Calls <code>world.flush()</code> after each phase (phase barrier). </li> </ul> <p>Example:</p> <pre><code>const phases = [\"input\", \"sim\", \"render\"];\nsched.run(world, 1/60, phases);\n</code></pre>"},{"location":"Reference/schedule/#flush-semantics","title":"Flush semantics","text":"<p><code>Schedule</code> relies on <code>world.flush()</code> to apply deferred structural changes queued via commands, enabling safe structural edits while systems and queries run. </p>"},{"location":"Reference/schedule/#relationship-to-worldupdatedt","title":"Relationship to <code>World.update(dt)</code>","text":"<ul> <li><code>world.update(dt)</code> runs the world\u2019s own registered systems and flushes at the end. </li> <li><code>Schedule</code> is used when you want explicit phase ordering and flush points between groups of systems rather than only at frame end. </li> </ul>"},{"location":"Reference/systems/","title":"Systems","text":""},{"location":"Reference/systems/#purpose","title":"Purpose","text":"<p>A system is a function executed by the ECS to update simulation state (usually by iterating queries and mutating component values). Systems are registered on the <code>World</code>, and executed during <code>world.update(dt)</code>. </p>"},{"location":"Reference/systems/#system-function-type","title":"System function type","text":""},{"location":"Reference/systems/#systemfn","title":"<code>SystemFn</code>","text":"<p>A system is a function with the signature:</p> <ul> <li><code>(world: WorldApi, dt: number) =&gt; void</code></li> </ul> <p>In practice, examples call <code>query()</code> and <code>cmd()</code> inside systems, which are available through <code>WorldApi</code>. </p>"},{"location":"Reference/systems/#registering-systems","title":"Registering systems","text":""},{"location":"Reference/systems/#worldaddsystemfn-this","title":"<code>world.addSystem(fn): this</code>","text":"<p>Adds a system to the world.</p> <ul> <li>Systems run in the order they were added (as described by \u201cruns systems in order\u201d). </li> </ul> <p>Example: </p> <pre><code>world.addSystem((w: any, dt: number) =&gt; {\n    for (const { e, c1: pos, c2: vel } of w.query(Position, Velocity)) {\n        pos.x += vel.x * dt;\n        pos.y += vel.y * dt;\n\n        if (pos.x &gt; 10) w.cmd().despawn(e);\n    }\n});\n</code></pre>"},{"location":"Reference/systems/#running-systems-frame-execution","title":"Running systems (frame execution)","text":""},{"location":"Reference/systems/#worldupdatedt-void","title":"<code>world.update(dt): void</code>","text":"<p>Runs one ECS frame:</p> <ol> <li>Runs all registered systems (in order)</li> <li>Flushes queued commands at the end </li> </ol> <p>The reference summary explicitly lists:</p> <ul> <li><code>addSystem(fn): this</code></li> <li><code>update(dt): void</code> (runs systems in order, then flushes) </li> </ul>"},{"location":"Reference/systems/#structural-changes-inside-systems","title":"Structural changes inside systems","text":"<p>While systems are running (and while iterating queries), doing structural changes directly can throw. The recommended pattern is:</p> <ul> <li>enqueue structural changes with <code>world.cmd()</code></li> <li>apply them with <code>world.flush()</code> (or let <code>update()</code> do it at the end) </li> </ul>"},{"location":"Reference/systems/#systems-in-phases-schedule","title":"Systems in phases (Schedule)","text":"<p>If you need explicit ordering across groups of systems, use <code>Schedule</code>:</p> <ul> <li><code>sched.add(phase, systemFn)</code></li> <li><code>sched.run(world, dt, phases)</code> runs phases in order and calls <code>world.flush()</code> after each phase </li> </ul> <p>This provides deterministic \u201cphase barriers\u201d where deferred commands are applied. </p>"},{"location":"Reference/world/","title":"World","text":""},{"location":"Reference/world/#purpose","title":"Purpose","text":"<p><code>World</code> is the central authority of the ECS. It owns and coordinates:</p> <ul> <li>entity lifecycle</li> <li>archetypes and component storage</li> <li>queries</li> <li>deferred structural commands</li> <li>system execution</li> </ul> <p>There is exactly one <code>World</code> instance per ECS context.</p>"},{"location":"Reference/world/#construction","title":"Construction","text":"<pre><code>const world = new World();\n</code></pre>"},{"location":"Reference/world/#side-effects","title":"Side effects","text":"<ul> <li>Initializes an empty entity pool</li> <li>Initializes archetype storage</li> <li>Initializes command buffer</li> <li>Initializes system list</li> </ul>"},{"location":"Reference/world/#entity-lifecycle-api","title":"Entity Lifecycle API","text":""},{"location":"Reference/world/#spawn-entity","title":"<code>spawn(): Entity</code>","text":"<p>Creates a new entity immediately.</p> <ul> <li>Allocates a new entity id</li> <li>Marks entity as alive</li> <li>Places entity in the empty archetype</li> </ul> <pre><code>const e = world.spawn();\n</code></pre>"},{"location":"Reference/world/#spawnmanyitems-componentctorbundleitem-entity","title":"<code>spawnMany(...items: ComponentCtorBundleItem[]): Entity</code>","text":"<p>Creates a new entity along with its initial components immediately.</p> <ul> <li><code>...items: ComponentCtorBundleItem[]</code> is the list of components to add to the newly created entity.</li> <li>Internally, it iterates over the items and calls <code>add</code> for each component.</li> </ul>"},{"location":"Reference/world/#despawne-entity-void","title":"<code>despawn(e: Entity): void</code>","text":"<p>Immediately removes an entity.</p> <ul> <li>Invalidates the entity handle (<code>gen</code> mismatch)</li> <li>Removes the entity from its archetype</li> <li>Frees the slot for reuse</li> </ul> <p>Throws if:</p> <ul> <li>entity is stale or not alive</li> </ul>"},{"location":"Reference/world/#despawnmanyentities-entity-void","title":"<code>despawnMany(entities: Entity[]): void</code>","text":"<p>Immediately removes multiple entities.</p> <ul> <li><code>entities: Entity[]</code> is the list of entities to despawn.</li> <li>Internally, it iterates over the array and calls <code>despawn(e)</code> for each entity.</li> </ul>"},{"location":"Reference/world/#isalivee-entity-boolean","title":"<code>isAlive(e: Entity): boolean</code>","text":"<p>Checks whether an entity handle is still valid.</p> <pre><code>if (world.isAlive(e)) { ... }\n</code></pre>"},{"location":"Reference/world/#component-api","title":"Component API","text":"<p>All component types are identified by constructor identity.</p>"},{"location":"Reference/world/#haste-entity-ctor-componentctort-boolean","title":"<code>has&lt;T&gt;(e: Entity, ctor: ComponentCtor&lt;T&gt;): boolean</code>","text":"<p>Checks if an entity has a component.</p>"},{"location":"Reference/world/#gette-entity-ctor-componentctort-t-undefined","title":"<code>get&lt;T&gt;(e: Entity, ctor: ComponentCtor&lt;T&gt;): T | undefined</code>","text":"<p>Returns the component value or <code>undefined</code>.</p> <ul> <li>Does not throw if missing</li> <li>Returns <code>undefined</code> for stale entities</li> </ul>"},{"location":"Reference/world/#addte-entity-ctor-componentctort-value-t-void","title":"<code>add&lt;T&gt;(e: Entity, ctor: ComponentCtor&lt;T&gt;, value: T): void</code>","text":"<p>Adds a component to an entity.</p> <ul> <li>Structural change</li> <li>Moves the entity to a different archetype</li> </ul> <p>Throws if:</p> <ul> <li>entity is stale</li> <li>component already exists</li> <li>structural changes are forbidden (see iteration rules)</li> </ul>"},{"location":"Reference/world/#addmanye-entity-items-componentctorbundleitem-void","title":"<code>addMany(e: Entity, ...items: ComponentCtorBundleItem[]): void</code>","text":"<p>Adding multiple components to an existing entity.</p> <ul> <li><code>e: Entity</code> is the target entity.</li> <li><code>...items: ComponentCtorBundleItem[]</code> is the list of components to add.</li> <li>Internally, it loops through the items and calls <code>add</code> for each component.</li> </ul>"},{"location":"Reference/world/#removete-entity-ctor-componentctort-void","title":"<code>remove&lt;T&gt;(e: Entity, ctor: ComponentCtor&lt;T&gt;): void</code>","text":"<p>Removes a component.</p> <ul> <li>Structural change</li> <li>Moves the entity to a different archetype</li> </ul> <p>Throws if:</p> <ul> <li>entity is stale</li> <li>component does not exist</li> <li>structural changes are forbidden</li> </ul>"},{"location":"Reference/world/#removemanye-entity-ctors-componentctorany-void","title":"<code>removeMany(e: Entity, ...ctors: ComponentCtor&lt;any&gt;[]): void</code>","text":"<p>Removes multiple component types from an entity.</p> <ul> <li><code>e: Entity</code> is the target entity.</li> <li><code>...ctors: ComponentCtor&lt;any&gt;[]</code> is the list of component constructors (types) to remove.</li> <li>Internally, it loops through the ctors and calls <code>remove</code> for each one.</li> </ul>"},{"location":"Reference/world/#sette-entity-ctor-componentctort-value-t-void","title":"<code>set&lt;T&gt;(e: Entity, ctor: ComponentCtor&lt;T&gt;, value: T): void</code>","text":"<p>Updates an existing component value.</p> <ul> <li>Non-structural</li> <li>Does not change archetypes</li> </ul> <p>Throws if:</p> <ul> <li>entity is stale</li> <li>component does not exist</li> </ul>"},{"location":"Reference/world/#query-api","title":"Query API","text":""},{"location":"Reference/world/#queryctors-iterablequeryrow","title":"<code>query(...ctors): Iterable&lt;QueryRow&gt;</code>","text":"<p>Iterates entities that contain all requested components.</p> <pre><code>for (const { e, c1, c2 } of world.query(A, B)) {\n    // e  -&gt; Entity\n    // c1 -&gt; A\n    // c2 -&gt; B\n}\n</code></pre>"},{"location":"Reference/world/#properties","title":"Properties","text":"<ul> <li>Iterates archetypes, not entities</li> <li>Components are returned as <code>c1</code>, <code>c2</code>, \u2026 in argument order</li> <li>Query iteration locks structural changes</li> </ul>"},{"location":"Reference/world/#structural-change-rules","title":"Structural Change Rules","text":"<p>While iterating a query or running systems:</p> <ul> <li>\u274c <code>spawn</code>, <code>despawn</code>, <code>add</code>, <code>remove</code> are forbidden</li> <li>\u2714\ufe0f <code>get</code>, <code>set</code>, <code>has</code> are allowed</li> </ul> <p>Violations throw a runtime error.</p>"},{"location":"Reference/world/#command-buffer-api","title":"Command Buffer API","text":""},{"location":"Reference/world/#cmd-commands","title":"<code>cmd(): Commands</code>","text":"<p>Returns a command buffer for deferred structural changes.</p> <pre><code>world.cmd().despawn(e);\n</code></pre> <p>Commands are queued, not applied immediately.</p>"},{"location":"Reference/world/#flush-void","title":"<code>flush(): void</code>","text":"<p>Applies all queued commands.</p> <ul> <li>Safe to call after queries</li> <li>Automatically called by <code>update()</code> and <code>Schedule</code></li> </ul>"},{"location":"Reference/world/#system-api","title":"System API","text":""},{"location":"Reference/world/#addsystemfn-systemfn-this","title":"<code>addSystem(fn: SystemFn): this</code>","text":"<p>Registers a system.</p> <pre><code>world.addSystem((w, dt) =&gt; { ... });\n</code></pre> <p>Systems are executed in insertion order.</p>"},{"location":"Reference/world/#updatedt-number-void","title":"<code>update(dt: number): void</code>","text":"<p>Runs one ECS frame.</p> <p>Execution order:</p> <ol> <li>Run all systems</li> <li>Flush deferred commands</li> </ol> <pre><code>world.update(1 / 60);\n</code></pre>"},{"location":"Reference/world/#events-api","title":"Events API","text":""},{"location":"Reference/world/#emittkey-componentctort-ev-t-void","title":"<code>emit&lt;T&gt;(key: ComponentCtor&lt;T&gt;, ev: T): void</code>","text":"<p>Emits an event of type <code>T</code> into the current phase write buffer.</p>"},{"location":"Reference/world/#eventstkey-componentctort-eventchannelt","title":"<code>events&lt;T&gt;(key: ComponentCtor&lt;T&gt;): EventChannel&lt;T&gt;</code>","text":"<p>Returns the event channel for <code>key</code>, creating it if missing.</p>"},{"location":"Reference/world/#draineventstkey-componentctort-fn-ev-t-void-void","title":"<code>drainEvents&lt;T&gt;(key: ComponentCtor&lt;T&gt;, fn: (ev: T) =&gt; void): void</code>","text":"<p>Drains readable events for the given type.</p> <p>Behavior</p> <ul> <li>If the channel doesn\u2019t exist yet, it\u2019s a no-op (does not allocate/create)</li> </ul>"},{"location":"Reference/world/#cleareventstkey-componentctort-void","title":"<code>clearEvents&lt;T&gt;(key?: ComponentCtor&lt;T&gt;): void</code>","text":"<p>Clears readable events.</p> <ul> <li>If <code>key</code> is provided: clears that event type\u2019s read buffer</li> <li>If omitted: clears the read buffers of all event types</li> </ul>"},{"location":"Reference/world/#swapevents-void-internal-schedule-boundary","title":"<code>swapEvents(): void</code> (internal / schedule boundary)","text":"<p>Swaps all event channels\u2019 buffers. Called by <code>Schedule</code> at phase boundaries.</p> <p>Required schedule behavior At each phase boundary:</p> <pre><code>world.flush();\nworld.swapEvents();\n</code></pre>"},{"location":"Reference/world/#internal-guarantees","title":"Internal Guarantees","text":"<ul> <li>Archetypes use Structure of Arrays (SoA)</li> <li>Entity handles are generation-safe</li> <li>Component lookups are O(1) per archetype row</li> <li>Queries are archetype-filtered, not entity-scanned</li> </ul>"},{"location":"Reference/world/#error-conditions-summary","title":"Error Conditions (Summary)","text":"Operation Error Condition add / remove during query iteration add component already exists remove component missing set component missing any stale entity"},{"location":"Reference/world/#design-constraints","title":"Design Constraints","text":"<ul> <li>Single-threaded</li> <li>No automatic conflict detection</li> <li>No parallel systems</li> <li>No borrowing model</li> </ul> <p>These are intentional for simplicity and predictability.</p>"},{"location":"Tutorials/Tutorial-1%E2%80%94Your-first-ECS-World/","title":"Tutorial 1 \u2014 Your first ECS World","text":"<p>Outcome: you\u2019ll run a tiny simulation loop where entities with <code>Position</code> + <code>Velocity</code> move over time, using <code>World</code>, <code>spawn</code>, <code>add</code>, <code>query</code>, <code>addSystem</code>, and <code>update(dt)</code>. </p>"},{"location":"Tutorials/Tutorial-1%E2%80%94Your-first-ECS-World/#1-what-is-an-ecs-one-sentence","title":"1) What is an ECS? (one sentence)","text":"<p>ECS is a way to build simulations where entities are IDs, components are data, and systems are functions that iterate entities with specific components. </p>"},{"location":"Tutorials/Tutorial-1%E2%80%94Your-first-ECS-World/#2-create-a-tiny-project","title":"2) Create a tiny project","text":"<pre><code>mkdir ecs-tutorial-1\ncd ecs-tutorial-1\nnpm init -y\nnpm i archetype-ecs-lib\nnpm i -D typescript tsx\n</code></pre> <p>Install is <code>npm i archetype-ecs-lib</code>. </p>"},{"location":"Tutorials/Tutorial-1%E2%80%94Your-first-ECS-World/#3-create-tutorial1ts","title":"3) Create <code>tutorial1.ts</code>","text":"<p>Create a file named <code>tutorial1.ts</code> with this code:</p> <pre><code>import { World, WorldApi } from \"archetype-ecs-lib\";\n\n// 1) Components = data (any class can be a component type)\nclass Position { constructor(public x = 0, public y = 0) {} }\nclass Velocity { constructor(public x = 0, public y = 0) {} }\n\n// 2) Create a World (owns entities, components, systems)\nconst world = new World();\n\n// 3) Spawn an entity and add components\nconst e = world.spawnMany(\n  new Position(0, 0, 0),\n  new Velocity(2, 0)// 2 units/sec along x\n)\n\n// 4) Add a system (runs each update)\nworld.addSystem((w, dt) =&gt; {\n  for (const { e, c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x * dt;\n    pos.y += vel.y * dt;\n  }\n});\n\n// 5) Run a small simulation loop (60 frames)\nconst dt = 1 / 60;\n\nfor (let frame = 1; frame &lt;= 60; frame++) {\n  world.update(dt);\n\n  // Read back Position and print it\n  const pos = world.get(e, Position)!;\n  if (frame % 10 === 0) {\n    console.log(`frame ${frame}: x=${pos.x.toFixed(2)} y=${pos.y.toFixed(2)}`);\n  }\n}\n</code></pre> <p>This uses the documented API:</p> <ul> <li><code>spawn()</code>, <code>add(e, Ctor, value)</code></li> <li><code>addSystem(fn)</code></li> <li><code>query(Position, Velocity)</code> yielding <code>{ e, c1, c2 }</code></li> <li><code>update(dt)</code> to run systems each tick</li> </ul>"},{"location":"Tutorials/Tutorial-1%E2%80%94Your-first-ECS-World/#4-run-it","title":"4) Run it","text":"<pre><code>npx tsx tutorial1.ts\n</code></pre> <p>You should see something like:</p> <ul> <li><code>frame 10: x=0.33 ...</code></li> <li><code>frame 60: x=2.00 ...</code></li> </ul> <p>(Your exact decimals may differ slightly depending on rounding.)</p>"},{"location":"Tutorials/Tutorial-1%E2%80%94Your-first-ECS-World/#5-youve-built-the-core-loop","title":"5) You\u2019ve built the core loop","text":"<p>You now have:</p> <ul> <li>a <code>World</code></li> <li>entities created with <code>spawn()</code></li> <li>components added with <code>add()</code></li> <li>a system iterating <code>query(...)</code></li> <li>a running simulation driven by <code>update(dt)</code> </li> </ul>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/","title":"Tutorial 2 \u2014 Components &amp; archetypes","text":"<p>Outcome: you\u2019ll see how component sets automatically form archetypes (tables), and how entities \u201cmove\u201d between them when you <code>add()</code> / <code>remove()</code> components\u2014without digging into internals. Archetypes store data in SoA (one column per component type). </p>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#1-define-a-few-component-types","title":"1) Define a few component types","text":"<p>Create <code>tutorial2.ts</code>:</p> <pre><code>import { World } from \"archetype-ecs-lib\";\n\n// Components are just data classes\nclass Position { constructor(public x = 0, public y = 0) {} }\nclass Velocity { constructor(public x = 0, public y = 0) {} }\nclass Health   { constructor(public hp = 100) {} }\n</code></pre> <p>The ECS uses component constructors as the \u201ctype key\u201d, and archetypes store entities in SoA tables. </p>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#2-create-a-world-and-spawn-entities-with-different-component-sets","title":"2) Create a World and spawn entities with different component sets","text":"<pre><code>const world = new World();\n\n// e1 has: Position\nconst e1 = world.spawn();\nworld.add(e1, Position, new Position(1, 1));\n\n// e2 has: Position + Velocity\nconst e2 = world.spawn();\nworld.add(e2, Position, new Position(0, 0));\nworld.add(e2, Velocity, new Velocity(1, 0));\n\n// e3 has: Health\nconst e3 = world.spawn();\nworld.add(e3, Health, new Health(50));\n</code></pre>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#3-add-a-tiny-helper-to-see-matches","title":"3) Add a tiny helper to \u201csee\u201d matches","text":"<p>We can\u2019t (and don\u2019t need to) access archetype tables directly. Instead, we observe which queries match, before and after structural changes.</p> <pre><code>function ids(iter: Iterable&lt;{ e: { id: number } }&gt;): number[] {\n  const out: number[] = [];\n  for (const row of iter) out.push(row.e.id);\n  return out.sort((a, b) =&gt; a - b);\n}\n\nfunction dump(label: string) {\n  console.log(`\\n=== ${label} ===`);\n  console.log(\"Position:\", ids(world.query(Position)));\n  console.log(\"Velocity:\", ids(world.query(Velocity)));\n  console.log(\"Health:  \", ids(world.query(Health)));\n  console.log(\"Pos+Vel: \", ids(world.query(Position, Velocity)));\n  console.log(\"Pos+HP:  \", ids(world.query(Position, Health)));\n}\n</code></pre> <p>The query API yields <code>{ e, c1, c2, ... }</code> rows in the order you request components. </p>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#4-observe-the-automatic-archetypes-effect","title":"4) Observe the \u201cautomatic archetypes\u201d effect","text":"<p>Add this and run once:</p> <pre><code>dump(\"initial\");\n</code></pre> <p>You\u2019ll see (by IDs) that:</p> <ul> <li><code>e1</code> matches <code>Position</code> only</li> <li><code>e2</code> matches both <code>Position</code> and <code>Pos+Vel</code></li> <li><code>e3</code> matches <code>Health</code> only</li> </ul> <p>What this demonstrates: entities with the same component set are stored together (same archetype). Archetypes are created implicitly as you introduce new component combinations. </p>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#5-make-an-entity-move-between-archetypes-add","title":"5) Make an entity \u201cmove\u201d between archetypes (add)","text":"<p>Now add a component to <code>e1</code>:</p> <pre><code>world.add(e1, Velocity, new Velocity(0, 2));\ndump(\"after: add Velocity to e1\");\n</code></pre> <p>You should see:</p> <ul> <li><code>e1</code> now appears in <code>Velocity</code></li> <li>and also in <code>Pos+Vel</code></li> </ul> <p>Why: <code>add()</code> is a structural change that can move an entity into a different archetype table (because its component set changed). </p>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#6-make-an-entity-move-between-archetypes-remove","title":"6) Make an entity \u201cmove\u201d between archetypes (remove)","text":"<p>Now remove <code>Position</code> from <code>e2</code>:</p> <pre><code>world.remove(e2, Position);\ndump(\"after: remove Position from e2\");\n</code></pre> <p>You should see:</p> <ul> <li><code>e2</code> disappears from <code>Position</code> and <code>Pos+Vel</code></li> <li><code>e2</code> still appears in <code>Velocity</code></li> </ul> <p>Again: <code>remove()</code> is structural and can move the entity to a new archetype. </p>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#7-run-it","title":"7) Run it","text":"<pre><code>npx tsx tutorial2.ts\n</code></pre>"},{"location":"Tutorials/Tutorial-2%E2%80%94Components-%26-archetypes/#what-you-just-learned-by-doing","title":"What you just learned (by doing)","text":"<ul> <li>Components are plain data types (classes). </li> <li>Archetypes (tables) are created automatically for each distinct component set, stored in SoA layout. </li> <li>When you <code>add()</code>/<code>remove()</code> components, entities \u201cmove\u201d because their component set changes (structural change). </li> </ul> <p>Note for later tutorials: structural changes can be unsafe while iterating; that\u2019s why <code>cmd()</code> + <code>flush()</code> exist. </p>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/","title":"Tutorial 3 \u2014 Deferred structural changes","text":"<p>Outcome: you\u2019ll learn the one rule that prevents most ECS bugs: don\u2019t change entity structure while iterating. You\u2019ll reproduce the problem safely, then fix it using Commands and flush points (via <code>Schedule</code>). The library explicitly supports this workflow: defer structural operations with <code>world.cmd()</code> and apply them with <code>world.flush()</code> / <code>Schedule</code> phase boundaries. </p>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#1-create-tutorial4ts","title":"1) Create <code>tutorial4.ts</code>","text":"<pre><code>import { World, WorldApi, Schedule } from \"archetype-ecs-lib\";\n</code></pre>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#2-define-simple-components","title":"2) Define simple components","text":"<pre><code>class Position { constructor(public x = 0) {} }\nclass Velocity { constructor(public x = 0) {} }\n</code></pre>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#3-setup-spawn-a-few-movers","title":"3) Setup: spawn a few movers","text":"<pre><code>const world = new World();\n\nfunction spawnMover(x: number, vx: number) {\n  const e = world.spawn();\n  world.add(e, Position, new Position(x));\n  world.add(e, Velocity, new Velocity(vx));\n  return e;\n}\n\nspawnMover(0,  2);\nspawnMover(5, -3);\nspawnMover(9,  1);\n</code></pre> <p>This is standard structural usage: <code>spawn()</code> + <code>add()</code>. </p>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#4-the-unsafe-thing-dont-do-this","title":"4) The unsafe thing (don\u2019t do this)","text":"<p>Add this function:</p> <pre><code>const unsafeDespawnInsideQuery: SystemFn = (w: WorldApi) =&gt; {\n  for (const { e, c1: pos } of w.query(Position)) {\n    if (pos.x &gt; 8) {\n      // \u274c Structural change during iteration (may throw)\n      w.despawn(e);\n    }\n  }\n}\n</code></pre> <p>Now call it once (inside a try/catch so the tutorial keeps going):</p> <pre><code>try {\n  unsafeDespawnInsideQuery(world);\n  console.log(\"unsafe: no error (but still not safe)\");\n} catch (err: any) {\n  console.log(\"unsafe: error as expected -&gt;\", String(err.message ?? err));\n}\n</code></pre> <p>The lib will warn that structural changes during query iteration can throw and instructs to use <code>cmd()</code> + <code>flush()</code> instead. </p>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#5-the-safe-fix-use-commands","title":"5) The safe fix: use Commands","text":"<p>Replace the unsafe function with a safe one:</p> <pre><code>const safeDespawnInsideQuery: SystemFn = (w: WorldApi) =&gt; {\n  for (const { e, c1: pos } of w.query(RenderContextComponent)) {\n    if (pos.x &gt; 8) {\n      // \u2705 Defer structural change\n      w.cmd().despawn(e);\n    }\n  }\n}\n</code></pre> <p>Commands let you queue:</p> <ul> <li><code>spawn</code>, <code>despawn</code>, <code>add</code>, <code>remove</code> </li> </ul>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#6-apply-commands-at-a-flush-point","title":"6) Apply commands at a flush point","text":""},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#option-a-manual-flush","title":"Option A \u2014 Manual flush","text":"<pre><code>safeDespawnInsideQuery(world);\nworld.flush(); // apply queued despawns\n</code></pre> <p><code>flush()</code> applies queued commands (and <code>update()</code> also flushes automatically at the end). </p>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#option-b-flush-at-phase-boundaries-recommended","title":"Option B \u2014 Flush at phase boundaries (recommended)","text":"<p>Use <code>Schedule</code>, which flushes after each phase:</p> <pre><code>const sched = new Schedule();\n\nsched.add(\"sim\", (w: WorldApi) =&gt; {\n  // move\n  for (const { c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x;\n  }\n});\n\nsched.add(\"cleanup\", (w: WorldApi) =&gt; {\n  // safely despawn based on updated positions\n  safeDespawnInsideQuery(w);\n});\n\n// Flush happens after each phase automatically\nconst phases = [\"sim\", \"cleanup\"];\n</code></pre> <p><code>Schedule.run(world, dt, phases)</code> runs phases and calls <code>world.flush()</code> after each phase. </p>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#7-run-a-few-ticks-and-print-whats-left","title":"7) Run a few ticks and print what\u2019s left","text":"<p>Add a small logger:</p> <pre><code>function logPositions(w: WorldApi, label: string) {\n  const items: string[] = [];\n  for (const { e, c1: pos } of w.query(Position)) {\n    items.push(`e${e.id}:${pos.x.toFixed(1)}`);\n  }\n  console.log(label, items.join(\" | \") || \"(none)\");\n}\n</code></pre> <p>Now run:</p> <pre><code>logPositions(world, \"before\");\n\nfor (let i = 0; i &lt; 5; i++) {\n  sched.run(world, 0, phases);\n  logPositions(world, `after tick ${i + 1}`);\n}\n</code></pre>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#8-full-file-copypaste","title":"8) Full file (copy/paste)","text":"<pre><code>import { World, Schedule } from \"archetype-ecs-lib\";\n\nclass Position { constructor(public x = 0) {} }\nclass Velocity { constructor(public x = 0) {} }\n\nconst world = new World();\n\nfunction spawnMover(x: number, vx: number) {\n  const e = world.spawn();\n  world.add(e, Position, new Position(x));\n  world.add(e, Velocity, new Velocity(vx));\n  return e;\n}\n\nspawnMover(0,  2);\nspawnMover(5, -3);\nspawnMover(9,  1);\n\nconst unsafeDespawnInsideQuery: SystemFn = (w) =&gt; {\n  for (const { e, c1: pos } of w.query(Position)) {\n    if (pos.x &gt; 8) {\n      w.despawn(e); // \u274c may throw\n    }\n  }\n}\n\ntry {\n  unsafeDespawnInsideQuery(world as any);\n  console.log(\"unsafe: no error (but still not safe)\");\n} catch (err: any) {\n  console.log(\"unsafe: error as expected -&gt;\", String(err.message ?? err));\n}\n\nconst safeDespawnInsideQuery: SystemFn = (w) =&gt; {\n  for (const { e, c1: pos } of w.query(Position)) {\n    if (pos.x &gt; 8) w.cmd().despawn(e); // \u2705 deferred\n  }\n}\n\nfunction logPositions(w: WorldApi, label: string) {\n  const items: string[] = [];\n  for (const { e, c1: pos } of w.query(Position)) {\n    items.push(`e${e.id}:${pos.x.toFixed(1)}`);\n  }\n  console.log(label, items.join(\" | \") || \"(none)\");\n}\n\nconst sched = new Schedule();\n\nsched.add(\"sim\", (w: WorldApi) =&gt; {\n  for (const { c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x;\n  }\n});\n\nsched.add(\"cleanup\", (w: WorldApi) =&gt; {\n  safeDespawnInsideQuery(w);\n});\n\nconst phases = [\"sim\", \"cleanup\"];\n\nlogPositions(world, \"before\");\nfor (let i = 0; i &lt; 5; i++) {\n  sched.run(world, 0, phases); // flush after each phase\n  logPositions(world, `after tick ${i + 1}`);\n}\n</code></pre>"},{"location":"Tutorials/Tutorial-3%E2%80%94Deferred-structural-changes/#9-run-it","title":"9) Run it","text":"<pre><code>npx tsx tutorial4.ts\n</code></pre> <p>You\u2019ll see:</p> <ul> <li>the unsafe version may throw (depending on timing/guarding)</li> <li>the safe version consistently despawns entities after they cross the threshold</li> <li>phase flush points make the timing predictable </li> </ul>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/","title":"Tutorial 4 \u2014 Writing systems","text":"<p>Outcome: you\u2019ll write real gameplay logic as systems: query components, mutate data safely, and run everything through a Schedule (<code>input \u2192 sim \u2192 cleanup</code>) with automatic <code>flush()</code> between phases. </p>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#1-create-tutorial3ts","title":"1) Create <code>tutorial3.ts</code>","text":"<pre><code>import { World, WorldApi, Schedule, SystemFn } from \"archetype-ecs-lib\";\n</code></pre> <p>The lib exports <code>World</code> and <code>Schedule</code>. </p>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#2-define-components-data-only","title":"2) Define components (data only)","text":"<pre><code>class Position { constructor(public x = 0, public y = 0) {} }\nclass Velocity { constructor(public x = 0, public y = 0) {} }\nclass Lifetime { constructor(public seconds = 1.0) {} } // despawn when &lt;= 0\n</code></pre>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#3-create-a-world-and-spawn-a-few-entities","title":"3) Create a World and spawn a few entities","text":"<pre><code>const world = new World();\n\nfunction spawnMover(x: number, y: number, vx: number, vy: number, life = 2.0) {\n  const e = world.spawn();\n  world.add(e, Position, new Position(x, y));\n  world.add(e, Velocity, new Velocity(vx, vy));\n  world.add(e, Lifetime, new Lifetime(life));\n  return e;\n}\n\nspawnMover(0, 0,  2, 0, 1.2);\nspawnMover(0, 1,  1, 0, 2.5);\nspawnMover(0, 2, -1, 0, 0.8);\n</code></pre> <p>This uses the documented structural ops: <code>spawn()</code> and <code>add()</code>. </p>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#4-system-function-signature-what-you-write","title":"4) System function signature (what you write)","text":"<p>A system is a function called like:</p> <ul> <li><code>(world, dt) =&gt; void</code></li> </ul> <p>Systems are added using <code>world.addSystem()</code> like <code>world.addSystem((w: WorldApi, dt: number) =&gt; ...)</code>. </p> <p>In this tutorial we\u2019ll register systems on a <code>Schedule</code> (phases), but the function shape is the same.</p>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#5-write-your-first-real-system-movement","title":"5) Write your first real system: movement","text":"<p>This system queries <code>Position + Velocity</code> and updates positions.</p> <pre><code>const movementSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {\n  for (const { c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x * dt;\n    pos.y += vel.y * dt;\n  }\n}\n</code></pre> <p>Query rows provide <code>{ e, c1, c2, ... }</code> in the same order as the query arguments. </p>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#6-mutating-data-safely-despawn-using-commands","title":"6) Mutating data safely: despawn using commands","text":"<p>Despawning is a structural change, so do it through <code>cmd()</code> inside systems.</p> <pre><code>const lifetimeSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {\n  for (const { e, c1: life } of w.query(Lifetime)) {\n    life.seconds -= dt;\n    if (life.seconds &lt;= 0) {\n      w.cmd().despawn(e); // safe: deferred\n    }\n  }\n}\n</code></pre>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#7-add-a-small-cleanup-log-system","title":"7) Add a small \u201ccleanup / log\u201d system","text":"<p>We\u2019ll print positions so you can see it running. This does not do structural changes.</p> <pre><code>const logSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {\n  const lines: string[] = [];\n  for (const { e, c1: pos } of w.query(Position)) {\n    lines.push(`e${e.id} @ (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)})`);\n  }\n  console.log(`frame ${frame}: ${lines.join(\" | \")}`);\n}\n</code></pre>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#8-run-systems-via-schedule-phases","title":"8) Run systems via Schedule (phases)","text":"<ol> <li>Create a schedule</li> <li>Register systems under phases</li> <li>Run phases each tick</li> </ol> <pre><code>const sched = new Schedule();\n\nsched.add(\"sim\", movementSystem);\nsched.add(\"sim\", lifetimeSystem);\n\n// log in a separate phase so structural changes are already flushed\nlet frameNo = 0;\nsched.add(\"cleanup\", (w: WorldApi) =&gt; {\n  frameNo++;\n  logSystem(w, frameNo);\n});\n\nconst phases = [\"sim\", \"cleanup\"];\n</code></pre> <p><code>Schedule.run(world, dt, phases)</code> runs phases in order and calls <code>world.flush()</code> after each phase. </p>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#9-run-the-loop","title":"9) Run the loop","text":"<pre><code>const dt = 1 / 10; // bigger dt so it\u2019s easy to see\nfor (let i = 0; i &lt; 20; i++) {\n  sched.run(world, dt, phases);\n}\n</code></pre>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#10-full-file-copypaste","title":"10) Full file (copy/paste)","text":"<pre><code>import { World, WorldApi Schedule, SystemFn } from \"archetype-ecs-lib\";\n\nclass Position { constructor(public x = 0, public y = 0) {} }\nclass Velocity { constructor(public x = 0, public y = 0) {} }\nclass Lifetime { constructor(public seconds = 1.0) {} }\n\nconst world = new World();\n\nfunction spawnMover(x: number, y: number, vx: number, vy: number, life = 2.0) {\n  const e = world.spawn();\n  world.add(e, Position, new Position(x, y));\n  world.add(e, Velocity, new Velocity(vx, vy));\n  world.add(e, Lifetime, new Lifetime(life));\n  return e;\n}\n\nspawnMover(0, 0,  2, 0, 1.2);\nspawnMover(0, 1,  1, 0, 2.5);\nspawnMover(0, 2, -1, 0, 0.8);\n\nconst movementSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {\n  for (const { c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x * dt;\n    pos.y += vel.y * dt;\n  }\n}\n\nconst lifetimeSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {\n  for (const { e, c1: life } of w.query(Lifetime)) {\n    life.seconds -= dt;\n    if (life.seconds &lt;= 0) w.cmd().despawn(e);\n  }\n}\n\nconst logSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {\n  const lines: string[] = [];\n  for (const { e, c1: pos } of w.query(Position)) {\n    lines.push(`e${e.id} @ (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)})`);\n  }\n  console.log(`frame ${frame}: ${lines.join(\" | \")}`);\n}\n\nconst sched = new Schedule();\nsched.add(\"sim\", movementSystem);\nsched.add(\"sim\", lifetimeSystem);\n\nlet frameNo = 0;\nsched.add(\"cleanup\", (w: WorldApi) =&gt; {\n  frameNo++;\n  logSystem(w, frameNo);\n});\n\nconst phases = [\"sim\", \"cleanup\"];\n\nconst dt = 1 / 10;\nfor (let i = 0; i &lt; 20; i++) {\n  sched.run(world, dt, phases);\n}\n</code></pre>"},{"location":"Tutorials/Tutorial-4%E2%80%94Writing-systems/#11-run-it","title":"11) Run it","text":"<pre><code>npx tsx tutorial3.ts\n</code></pre> <p>You\u2019ll see entities moving, then disappearing as their <code>Lifetime</code> reaches 0 (despawned safely via commands + phase flush). </p>"},{"location":"Tutorials/Tutorial-5%E2%80%94ECS-%2B-Three.js/","title":"Tutorial 5 \u2014 ECS + Three.js (render-sync + safe spawn/despawn)","text":"<p>Outcome: you\u2019ll see moving cubes in Three.js. You\u2019ll also spawn new cubes on click and despawn them safely using <code>cmd()</code> + phase flush boundaries (via <code>Schedule</code>). </p>"},{"location":"Tutorials/Tutorial-5%E2%80%94ECS-%2B-Three.js/#1-create-a-new-project","title":"1) Create a new project","text":"<pre><code>mkdir ecs-threejs-tutorial\ncd ecs-threejs-tutorial\nnpm init -y\n\nnpm i archetype-ecs-lib three\nnpm i -D vite typescript\n</code></pre> <p>The ECS package is installed as <code>archetype-ecs-lib</code>. </p>"},{"location":"Tutorials/Tutorial-5%E2%80%94ECS-%2B-Three.js/#2-add-indexhtml","title":"2) Add <code>index.html</code>","text":"<p>Create <code>index.html</code>:</p> <pre><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;ECS + Three.js Tutorial&lt;/title&gt;\n    &lt;style&gt;\n      html, body { margin: 0; height: 100%; overflow: hidden; }\n      #hud {\n        position: fixed; left: 12px; top: 12px;\n        padding: 8px 10px; border-radius: 8px;\n        background: rgba(0,0,0,0.55); color: #fff;\n        font-family: system-ui, sans-serif; font-size: 13px;\n        user-select: none;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"hud\"&gt;Click to spawn cubes&lt;/div&gt;\n    &lt;script type=\"module\" src=\"/src/main.ts\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"Tutorials/Tutorial-5%E2%80%94ECS-%2B-Three.js/#3-add-srcmaints","title":"3) Add <code>src/main.ts</code>","text":"<p>Create <code>src/main.ts</code>:</p> <pre><code>import * as THREE from \"three\";\nimport { World, WorldApi, Schedule, SystemFn } from \"archetype-ecs-lib\";\n\n// --------------------\n// Components (data only)\n// --------------------\nclass Position { constructor(public x = 0, public y = 0, public z = 0) {} }\nclass Velocity { constructor(public x = 0, public y = 0, public z = 0) {} }\nclass Lifetime { constructor(public seconds = 2.0) {} }\nclass Renderable { constructor(public kind: \"cube\" = \"cube\") {} }\n\n// --------------------\n// Three.js setup\n// --------------------\nconst renderer = new THREE.WebGLRenderer({ antialias: true });\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n\nconst scene = new THREE.Scene();\nscene.background = new THREE.Color(0x101018);\n\nconst camera = new THREE.PerspectiveCamera(\n  60,\n  window.innerWidth / window.innerHeight,\n  0.1,\n  1000\n);\ncamera.position.set(0, 6, 14);\ncamera.lookAt(0, 0, 0);\n\nconst grid = new THREE.GridHelper(40, 40);\nscene.add(grid);\n\nwindow.addEventListener(\"resize\", () =&gt; {\n  camera.aspect = window.innerWidth / window.innerHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n});\n\n// --------------------\n// ECS setup\n// --------------------\nconst world = new World();\nconst sched = new Schedule();\n\n// Map ECS entities -&gt; Three.js objects\n// Use id+gen so reuse of ids never points to the wrong mesh.\nconst entityKey = (e: { id: number; gen: number }) =&gt; `${e.id}:${e.gen}`;\nconst objects = new Map&lt;string, THREE.Object3D&gt;();\n\nfunction makeObject(r: Renderable): THREE.Object3D {\n  // MeshNormalMaterial doesn't need lights\n  const geo = new THREE.BoxGeometry(1, 1, 1);\n  const mat = new THREE.MeshNormalMaterial();\n  const mesh = new THREE.Mesh(geo, mat);\n  mesh.castShadow = false;\n  mesh.receiveShadow = false;\n  return mesh;\n}\n\n// --------------------\n// Input: click to spawn\n// --------------------\nlet pendingClicks = 0;\nwindow.addEventListener(\"pointerdown\", () =&gt; pendingClicks++);\n\nconst inputPhase: SystemFn = (w: WorldApi) =&gt; {\n  if (pendingClicks &lt;= 0) return;\n\n  const cmd = w.cmd();\n  for (let i = 0; i &lt; pendingClicks; i++) {\n    cmd.spawn((e: any) =&gt; {\n      // Spawn near origin with random velocity and short lifetime\n      const x = (Math.random() - 0.5) * 8;\n      const z = (Math.random() - 0.5) * 8;\n\n      const vx = (Math.random() - 0.5) * 6;\n      const vz = (Math.random() - 0.5) * 6;\n\n      cmd.addBundle(\n        e,\n        [new Position(x, 0.5, z), new Velocity(vx, 0, vz), new Lifetime(2.0 + Math.random() * 2.0), new Renderable(\"cube\")]\n      );\n    });\n  }\n\n  pendingClicks = 0;\n}\n\n// --------------------\n// Simulation: movement\n// --------------------\nconst movementSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {\n  for (const { c1: pos, c2: vel } of w.query(Position, Velocity)) {\n    pos.x += vel.x * dt;\n    pos.y += vel.y * dt;\n    pos.z += vel.z * dt;\n\n    // simple bounds bounce\n    const limit = 12;\n    if (pos.x &lt; -limit || pos.x &gt; limit) vel.x *= -1;\n    if (pos.z &lt; -limit || pos.z &gt; limit) vel.z *= -1;\n  }\n}\n\n// --------------------\n// Simulation: lifetime -&gt; despawn (deferred)\n// --------------------\nconst lifetimeSystem: SystemFn = (w: WorldApi, dt: number) =&gt; {\n  for (const { e, c1: life } of w.query(Lifetime)) {\n    life.seconds -= dt;\n    if (life.seconds &lt;= 0) {\n      w.cmd().despawn(e); // structural change deferred\n    }\n  }\n}\n\n// --------------------\n// Render phase: ECS -&gt; Three.js sync + remove despawned\n// --------------------\nconst renderSync: SystemFn = (w: WorldApi) =&gt; {\n  const alive = new Set&lt;string&gt;();\n\n  // Create/update objects for all renderables\n  for (const { e, c1: pos, c2: rend } of w.query(Position, Renderable)) {\n    const key = entityKey(e);\n    alive.add(key);\n\n    let obj = objects.get(key);\n    if (!obj) {\n      obj = makeObject(rend);\n      scene.add(obj);\n      objects.set(key, obj);\n    }\n\n    obj.position.set(pos.x, pos.y, pos.z);\n  }\n\n  // Remove objects whose entities are gone\n  for (const [key, obj] of objects) {\n    if (!alive.has(key)) {\n      scene.remove(obj);\n      objects.delete(key);\n    }\n  }\n}\n\n// --------------------\n// Schedule: phase ordering + flush boundaries\n// --------------------\n// Schedule runs phases in order and calls world.flush() after each phase. :contentReference[oaicite:2]{index=2}\nsched.add(\"input\", inputPhase);\nsched.add(\"sim\", movementSystem);\nsched.add(\"sim\", lifetimeSystem);\nsched.add(\"render\", renderSync);\n\nconst phases = [\"input\", \"sim\", \"render\"];\n\n// --------------------\n// Animation loop\n// --------------------\nlet last = performance.now();\n\nfunction frame(now: number) {\n  const dt = Math.min(0.05, (now - last) / 1000);\n  last = now;\n\n  // Run ECS phases (flush after each phase)\n  sched.run(world, dt, phases);\n\n  // Render Three.js\n  renderer.render(scene, camera);\n\n  requestAnimationFrame(frame);\n}\n\nrequestAnimationFrame(frame);\n\n// Spawn a few cubes at start (via commands so it behaves like gameplay)\npendingClicks = 6;\n</code></pre> <p>This uses:</p> <ul> <li><code>Schedule.add(phase, fn)</code> and <code>Schedule.run(world, dt, phases)</code> with flush between phases </li> <li><code>world.query(A, B)</code> yielding <code>{ e, c1, c2 }</code> </li> <li>deferred structural ops via <code>cmd().spawn/add/despawn</code> </li> </ul>"},{"location":"Tutorials/Tutorial-5%E2%80%94ECS-%2B-Three.js/#4-run-it","title":"4) Run it","text":"<pre><code>npx vite\n</code></pre> <p>Open the local URL Vite prints.</p>"},{"location":"Tutorials/Tutorial-5%E2%80%94ECS-%2B-Three.js/#5-what-to-try-hands-on","title":"5) What to try (hands-on)","text":"<ol> <li>Click to spawn cubes</li> <li>Watch them move (ECS <code>Position</code> + <code>Velocity</code>)</li> <li>Watch them disappear after a few seconds (<code>Lifetime</code> \u2192 <code>cmd().despawn(e)</code>), and see the Three.js mesh removed automatically in <code>renderSync()</code>.</li> </ol> <p>That\u2019s the \u201csafe loop\u201d:</p> <ul> <li>structural requests happen inside systems using <code>cmd()</code></li> <li>structural changes become real at flush boundaries (Schedule phases)</li> <li>render-sync runs on a stable world snapshot </li> </ul>"}]}